class Solution
{
public:
    int minMalwareSpread(std::vector<std::vector<int>> & graph, std::vector<int> & initial)
    {
        auto n = static_cast<const int>(graph.size());

        std::iota(root.begin(), root.begin() + n, 0);
        std::fill_n(rank.begin(), n, 1);

        // Whether a node is initially infected. 
        std::fill_n(virus.begin(), n, false);

        // Number of nodes a virus will eventually infect. 
        std::fill_n(cnt.begin(), n, 0);

        // Whether a connected component (excluding all virus nodes)
        // stays uninfected (-1), infected by one virus node, 
        // or infected by multiple virus nodes (-2). 
        std::fill_n(infect.begin(), n, -1);

        // A connected component (excluding all virus nodes)
        // is savable iff. it will be infected by only one virus node. 

        for (int i : initial)
        {
            virus[i] = true;
        }

        for (int i = 0; i < n; ++i)
        {
            for (int j = i + 1; j < n; ++j)
            {
                if (graph[i][j] && !virus[i] && !virus[j])
                {
                    unite(i, j);
                }
            }
        }

        for (int sick : initial)
        {
            for (int neighbor = 0; neighbor < n; ++neighbor)
            {
                if (sick != neighbor && graph[sick][neighbor] && !virus[neighbor])
                {
                    int rn = find(neighbor);

                    if (infect[rn] == -1)
                    {
                        infect[rn] = sick;
                    }
                    else if (infect[rn] != -2 && infect[rn] != sick)
                    {
                        infect[rn] = -2;
                    }
                }
            }
        }

        for (int i = 0; i < n; ++i)
        {
            if (i == find(i) && 0 <= infect[i])
            {
                cnt[infect[i]] += rank[i];
            }
        }

        std::sort(initial.begin(), initial.end());

        int ans = initial.front();
        int maxi = 0;

        for (int i : initial)
        {
            if (maxi < cnt[i])
            {
                ans = i;
                maxi = cnt[i];
            }
        }

        return ans;
    }

private:
    int find(int x)
    {
        if (x == root[x]) return x;
        return root[x] = find(root[x]);
    }

    void unite(int x, int y)
    {
        int rx = find(x), ry = find(y);
        if (rx == ry) return;

        if (rank[rx] < rank[ry]) root[rx] = ry, rank[ry] += rank[rx];
        else root[ry] = rx, rank[rx] += rank[ry];
    }

private:
    static constexpr int kMaxSize = 310;
    static std::array<int, kMaxSize> root;
    static std::array<int, kMaxSize> rank;

    static std::array<bool, kMaxSize> virus;

    static std::array<int, kMaxSize> cnt;
    static std::array<int, kMaxSize> infect;
};

std::array<int, Solution::kMaxSize> Solution::root = {0};
std::array<int, Solution::kMaxSize> Solution::rank = {1};

std::array<bool, Solution::kMaxSize> Solution::virus = {false};

std::array<int, Solution::kMaxSize> Solution::cnt = {0};
std::array<int, Solution::kMaxSize> Solution::infect = {0};

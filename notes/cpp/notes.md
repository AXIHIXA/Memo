# ã€ŠC++ Primer 5th Editionã€‹ç¬”è®°

è®°å½•ä¸€äº›å¯¹C++ç†è§£å¾—ä¸åˆ°ä½çš„åœ°æ–¹ã€‚

### ğŸŒ± ä¸€å¥è¯

- å¸¸è§è§„åˆ™
    - å…ˆå£°æ˜ï¼ˆæˆ–å®šä¹‰ï¼‰å†ä½¿ç”¨ã€‚ *ç¬¬ä¸€æ¬¡å®é™…ä½¿ç”¨å‰* å†å£°æ˜ï¼ˆå®šä¹‰ï¼‰
    - **ä¸¥ç¦**æ··ç”¨æœ‰ç¬¦å·ç±»å‹å’Œæ— ç¬¦å·ç±»å‹ï¼ˆæ¯”å¦‚ï¼šè¯¥ç”¨`size_t`å°±ç”¨ï¼Œåˆ«å•¥ç©æ„éƒ½æ•´æˆ`int`ï¼‰
    - æ•´æ•°å’Œæµ®ç‚¹æ•°å­—é¢å€¼çš„åç¼€ä¸€å¾‹ä½¿ç”¨ *å¤§å†™* ç‰ˆæœ¬ï¼Œé¿å…`l`å’Œ`1`æ··æ·†
    - å¦‚æœå‡½æ•°æœ‰å¯èƒ½ç”¨åˆ°æŸä¸ªå…¨å±€å˜é‡ï¼Œåˆ™**ä¸å®œ**å†å®šä¹‰åŒåçš„å±€éƒ¨å˜é‡
    - `const`å¸¸é‡ä¸è®ºæ˜¯å£°æ˜è¿˜æ˜¯å®šä¹‰éƒ½æ·»åŠ `extern`ä¿®é¥°ç¬¦
    - æƒ³è¦`auto`æ¨å¯¼å‡ºå¼•ç”¨æˆ–è€…å¸¸é‡çš„è¯ï¼Œç›´æ¥å†™æ¸…æ¥šæ˜¯å å¼çš„ï¼ˆ`const auto & a = b`ï¼‰ï¼Œåˆ«æŠ˜è…¾é¡¶å±‚`const`ä»€ä¹ˆçš„
    - è®¤å®šåº”ä¸ºå¸¸é‡è¡¨è¾¾å¼çš„å˜é‡åº”å½“å£°æ˜ä¸º`constexpr`ç±»å‹
    - `constexpr`å‡½æ•°ã€é™æ€`constexpr`æˆå‘˜ã€`inline`å‡½æ•°ï¼ˆåŒ…æ‹¬ç±»çš„`inline`æˆå‘˜å‡½æ•°ï¼‰ä»¥åŠæ¨¡æ¿çš„**å®šä¹‰å’Œå®ç°éƒ½åº”**å†™è¿›å¤´æ–‡ä»¶
    - `using`å£°æ˜ï¼ˆ`using std::string`ã€`using namespace std`ã€`using intptr = int *`ç­‰ï¼‰**ä¸åº”**å†™è¿›å¤´æ–‡ä»¶
    - `for each`å¾ªç¯å†…ä»¥åŠä½¿ç”¨è¿­ä»£å™¨æ—¶**ä¸èƒ½**æ”¹å˜è¢«éå†çš„å®¹å™¨çš„å¤§å°
    - ç°ä»£`C++`åº”ä½¿ç”¨æ ‡å‡†åº“ç±»å‹é…åˆè¿­ä»£å™¨ï¼Œè€Œ**ä¸æ˜¯**`C`é£æ ¼çš„æ•°ç»„å’ŒæŒ‡é’ˆã€‚æ•°ç»„ä¹Ÿæ˜¯ä¸€ç§è¿­ä»£å™¨
    - ç°ä»£`C++`**ä¸åº”**ä½¿ç”¨æ—§å¼çš„å¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œåº”å½“æ˜ç¡®è°ƒç”¨å¯¹åº”çš„`xx_cast<T>(expr)`
    - é™¤éå¿…é¡»ï¼Œ**ä¸è¦**ä½¿ç”¨è‡ªå¢è‡ªå‡è¿ç®—ç¬¦çš„åç½®ç‰ˆæœ¬ï¼ˆä¼šé€ æˆæ€§èƒ½æµªè´¹ï¼‰
    - **ä¸åœ¨**å†…éƒ¨ä½œç”¨åŸŸå£°æ˜å‡½æ•°ï¼ˆå†…éƒ¨ä½œç”¨åŸŸç”Ÿå‘½çš„ä¸œè¥¿ä¼šè¦†ç›–å¤–éƒ¨ä½œç”¨åŸŸçš„åŒåä¸œè¥¿ï¼Œå¯èƒ½ä¼šå½±å“å‡½æ•°é‡è½½çš„ä½¿ç”¨ï¼‰
    - æ„é€ å‡½æ•°**ä¸åº”**è¯¥è¦†ç›–æ‰ç±»å†…åˆå§‹å€¼ï¼Œé™¤éæ–°å€¼ä¸åŸå€¼ä¸åŒï¼›ä¸ä½¿ç”¨ç±»å†…åˆå§‹å€¼æ—¶ï¼Œåˆ™æ¯ä¸ªæ„é€ å‡½æ•°**éƒ½åº”æ˜¾å¼åˆå§‹åŒ–**æ¯ä¸€ä¸ªç±»å†…æˆå‘˜
    - å¸Œæœ›ç±»çš„æ‰€æœ‰æˆå‘˜éƒ½æ˜¯`public`æ—¶ï¼Œ**åº”**ä½¿ç”¨`struct`ï¼›åªæœ‰å¸Œæœ›ä½¿ç”¨`private`æˆå‘˜æ—¶æ‰ç”¨`class`
    - åœ¨ç±»å®šä¹‰å¼€å§‹æˆ–ç»“æŸçš„åœ°æ–¹**é›†ä¸­å£°æ˜**å‹å…ƒï¼›ä½¿ç”¨å‹å…ƒï¼Œä»å¦éœ€æœ‰ä¸€ä¸ª**å•ç‹¬çš„å‡½æ•°å£°æ˜**
    - ç±»çš„ç±»å‹æˆå‘˜ï¼ˆ`typedef`ä»¥åŠ`using`å£°æ˜ï¼‰åº”è¯¥æ”¾åœ¨ç±»å®šä¹‰**åˆšå¼€å§‹**çš„åœ°æ–¹çš„`public`åŒºåŸŸ
    - æœ€å¥½ä»¤æ„é€ å‡½æ•°åˆå§‹åŒ–åˆ—è¡¨çš„é¡ºåºä¸æˆå‘˜å£°æ˜çš„é¡ºåº**ä¿æŒä¸€è‡´**ï¼›**é¿å…**ç”¨æŸäº›æˆå‘˜åˆå§‹åŒ–å…¶ä»–æˆå‘˜ï¼Œç”¨æ„é€ å‡½æ•°çš„å‚æ•°ä½œä¸ºåˆå§‹å€¼
    - åº”æŠŠé™æ€æ•°æ®æˆå‘˜çš„å®šä¹‰ä¸å…¶ä»–éå†…è”å‡½æ•°çš„å®šä¹‰æ”¾åœ¨**åŒä¸€ä¸ªæ–‡ä»¶**ä¸­
    - å³ä½¿ä¸€ä¸ª`constexpr`é™æ€æˆå‘˜åœ¨ç±»å†…éƒ¨è¢«åˆå§‹åŒ–äº†ï¼Œä¹Ÿåº”è¯¥åœ¨ç±»å¤–å®šä¹‰ä¸€ä¸‹è¯¥æˆå‘˜ï¼ˆæ­¤æ—¶**ä¸èƒ½**å†æŒ‡å®šåˆå§‹å€¼ï¼‰
    - ä¸éœ€è¦å†™è®¿é—®æ—¶ï¼Œåº”å½“ä½¿ç”¨`const_iterator`
    - æ”¹å˜å®¹å™¨ *å¤§å°* ä¹‹åï¼Œåˆ™ *æ‰€æœ‰* æŒ‡å‘æ­¤å®¹å™¨çš„è¿­ä»£å™¨ã€å¼•ç”¨å’ŒæŒ‡é’ˆéƒ½ *å¯èƒ½* å¤±æ•ˆï¼Œæ‰€ä»¥ä¸€å¾‹æ›´æ–°ä¸€æ³¢æ‰æ˜¯ *å å¼çš„* ã€‚æ­¤å¤–ï¼Œæ°¸è¿œ**ä¸è¦ç¼“å­˜**å°¾åè¿­ä»£å™¨ï¼ˆè¿™ç©æ„å¸¸å¹´å˜æ¥å˜å»ï¼‰ï¼Œç°ç”¨ç°åˆ¶ï¼Œç”¨åå³å¼ƒ
    - æ³›å‹ç¼–ç¨‹è¦æ±‚ï¼š**åº”å½“**ç»Ÿä¸€ä½¿ç”¨éæˆå‘˜ç‰ˆæœ¬çš„`swap`ï¼Œå³`std::swap(c1, c2);`
    - è°ƒç”¨æ³›å‹ç®—æ³•æ—¶ï¼Œåœ¨ä¸éœ€è¦ä½¿ç”¨è¿”å›çš„è¿­ä»£å™¨ä¿®æ”¹å®¹å™¨çš„æƒ…å†µä¸‹ï¼Œä¼ å‚åº”ä¸º`const_iterator`
    - `lambda`è¡¨è¾¾å¼åº”å°½é‡**é¿å…**æ•è·æŒ‡é’ˆæˆ–å¼•ç”¨ã€‚å¦‚æ•è·å¼•ç”¨ï¼Œå¿…é¡»ä¿è¯åœ¨`lambda`æ‰§è¡Œæ—¶å˜é‡ *ä»å­˜åœ¨* 
- ä¸€äº›å°çŸ¥è¯†
    - å¦‚æœä¸¤ä¸ªå­—ç¬¦ä¸²å­—é¢å€¼ä½ç½®ç´§é‚»ä¸”ä»…ç”± *ç©ºæ ¼* ã€ *ç¼©è¿›* ä»¥åŠ *æ¢è¡Œç¬¦* åˆ†éš”ï¼Œåˆ™å®ƒä»¬æ˜¯ *ä¸€ä¸ªæ•´ä½“* 
    - `C++11`è§„å®šæ•´æ•°é™¤æ³•å•†ä¸€å¾‹å‘0å–æ•´ï¼ˆå³ï¼š**ç›´æ¥åˆ‡é™¤å°æ•°éƒ¨åˆ†**ï¼‰
    - æŒ‡é’ˆè§£å¼•ç”¨çš„ç»“æœæ˜¯å…¶æŒ‡å‘å¯¹è±¡çš„**å·¦å€¼**å¼•ç”¨
    - `*iter++`ç­‰ä»·äº`*(iter++)` => ä¼˜å…ˆçº§ï¼š`++` > `*`
    - `p->ele`ç­‰ä»·äº`(*p).ele` => ä¼˜å…ˆçº§ï¼š`.` < `*`
    - `const`å¯¹è±¡è¢«è®¾å®šä¸º**ä»…åœ¨æ–‡ä»¶å†…æœ‰æ•ˆ**
    - `std::endl`æœ‰åˆ·æ–°ç¼“å†²åŒºçš„æ•ˆæœã€‚æœ€å¥½å¸¦ä¸Š
    - å¦‚æœä¸€ä¸ªå‡½æ•°æ˜¯æ°¸è¿œä¹Ÿä¸ä¼šç”¨åˆ°çš„ï¼Œé‚£ä¹ˆå®ƒå¯ä»¥åªæœ‰å£°æ˜è€Œæ²¡æœ‰å®šä¹‰ => 15.3
    - å¼•ç”¨ä»æ¥éƒ½æ˜¯ä½œä¸ºè¢«å¼•ç”¨å¯¹è±¡çš„åŒä¹‰è¯å‡ºç°ï¼ˆæ¯”å¦‚`auto`å°±ä¸èƒ½è‡ªåŠ¨æ¨æ–­å‡ºå¼•ç”¨ï¼‰ï¼Œå”¯ä¸€ä¾‹å¤–æ˜¯`decltype`ã€‚å®ƒä¼šåŸæ ·ä¿ç•™å¼•ç”¨ä»¥åŠé¡¶å±‚`const`
    - `main`å‡½æ•°ä¸èƒ½é€’å½’è°ƒç”¨ã€ä¸èƒ½é‡è½½
    - å®šä¹‰åœ¨ç±»å†…éƒ¨çš„å‡½æ•°æ˜¯éšå¼çš„`inline`å‡½æ•°
    - ä½¿ç”¨`struct`æˆ–`class`å®šä¹‰ç±»çš„**å”¯ä¸€åŒºåˆ«**å°±æ˜¯é»˜è®¤è®¿é—®æƒé™ï¼š`struct`ä¸­é»˜è®¤ *å…¬æœ‰* ï¼Œè€Œ`class`é»˜è®¤ *ç§æœ‰*
    - æ¯ä¸ªç±»å®šä¹‰äº†**å”¯ä¸€**çš„ç±»å‹ï¼›ä¸¤ä¸ªç±»å³ä½¿å†…å®¹å®Œå…¨ä¸€æ ·ï¼Œå®ƒä»¬ä¹Ÿæ˜¯ä¸åŒçš„ç±»å‹ï¼Œ**ä¸èƒ½**è‡ªåŠ¨ç›¸äº’è½¬åŒ–
    - å¦‚æœä¸€ä¸ªæ„é€ å‡½æ•°ä¸ºæ¯ä¸€ä¸ªå‚æ•°éƒ½æä¾›äº†é»˜è®¤å®å‚ï¼Œåˆ™å®ƒå®é™…ä¸Šä¹Ÿå®šä¹‰äº†é»˜è®¤æ„é€ å‡½æ•°
    - èƒ½é€šè¿‡ä¸€ä¸ªå®å‚è°ƒç”¨çš„æ„é€ å‡½æ•°å®šä¹‰äº†ä¸€æ¡ä»æ„é€ å‡½æ•°çš„å‚æ•°ç±»å‹å‘ç±»ç±»å‹éšå¼è½¬æ¢çš„è§„åˆ™
    - é`constexpr`é™æ€æˆå‘˜åªèƒ½åœ¨**ç±»å¤–**åˆå§‹åŒ–ï¼›åœ¨ç±»å¤–éƒ¨å®šä¹‰é™æ€æˆå‘˜æ—¶ï¼Œ**ä¸èƒ½**é‡å¤`static`å…³é”®å­—
    - å¦‚æœå®¹å™¨ä¸ºç©ºï¼Œåˆ™`begin`å’Œ`end`è¿”å›çš„æ˜¯**åŒä¸€ä¸ª**è¿­ä»£å™¨ï¼Œéƒ½æ˜¯å°¾åè¿­ä»£å™¨
    - è¿­ä»£å™¨ç®—æœ¯è¿ç®—ï¼ˆiterator arithmaticï¼‰**ä¸**æ”¯æŒ`std::list`ã€`std::forward_list`ï¼Œå› ä¸ºåŒå‘é“¾è¡¨å’Œå•å‘é“¾è¡¨å­˜å‚¨å…ƒç´ éƒ½ *ä¸åœ¨ä¸€å—è¿ç»­çš„å†…å­˜ä¸Š* ï¼Œæ‰€ä»¥æ— æ³•é€šè¿‡åŠ å‡æ³•æŒ‰è·ç¦»æŸ¥æ‰¾å…ƒç´ 
    - åªæœ‰å½“å…¶å…ƒç´ ç±»å‹ä¹Ÿå®šä¹‰äº†ç›¸åº”çš„æ¯”è¾ƒè¿ç®—ç¬¦æ—¶ï¼Œæ‰å¯ä»¥ä½¿ç”¨ *å…³ç³»è¿ç®—ç¬¦* æ¥æ¯”è¾ƒä¸¤ä¸ªå®¹å™¨
    - æ³›å‹ç®—æ³•**ä¸èƒ½ï¼ˆç›´æ¥ï¼‰æ·»åŠ æˆ–åˆ é™¤**å…ƒç´ ã€‚å…·ä½“æ¥è¯´ï¼Œè°ƒç”¨`std::unique()`ä¹‹å‰è¦æœ‰`std::sort()`ï¼Œä¹‹åè¿˜è¦è°ƒç”¨`c.erase()`æ¥å®é™…é‡Šæ”¾ç©ºé—´
- è¯»ä»£ç æ ‡å‡†æ“ä½œ
    - å¯¹å¤æ‚çš„å£°æ˜ç¬¦ï¼Œä»å˜é‡åçœ‹èµ·ï¼Œå…ˆå¾€å³ï¼Œå†å¾€å·¦ï¼Œç¢°åˆ°ä¸€ä¸ªåœ†æ‹¬å·å°±è°ƒè½¬é˜…è¯»çš„æ–¹å‘
      æ‹¬å·å†…åˆ†æå®Œå°±è·³å‡ºæ‹¬å·ï¼Œè¿˜æ˜¯æŒ‰å…ˆå³åå·¦çš„é¡ºåºï¼Œå¦‚æ­¤å¾ªç¯ï¼Œç›´åˆ°æ•´ä¸ªå£°æ˜åˆ†æå®Œ
        - ä¸¾ä¾‹ï¼š`int (*(*pf)(int, int (*(*)(int))[20]))[10]`ï¼š
            - æŒ‰é¡ºåºç¿»è¯‘ä¸ºï¼šdeclare `pf` as pointer to function (int, pointer to function (int) returning pointer to array 20 of int) returning pointer to array 10 of int
        - å¤§å®è´ï¼š[cdecl](https://cdecl.org/) ï¼Œå®‰è£…ï¼š`sudo apt install cdecl`
    - åˆ¤æ–­å¤æ‚ç±»å‹`auto`å˜é‡çš„ç±»å‹ï¼šå…ˆæ‰’æ‰å¼•ç”¨ï¼Œå†æ‰’æ‰è¢«å¼•ç”¨è€…çš„é¡¶å±‚`const`

### ğŸŒ± å­—é¢å€¼ï¼ˆliteralï¼‰

- *æ•´æ•°* 
    - å¯ä»¥å†™ä½œåè¿›åˆ¶ã€å…«è¿›åˆ¶ï¼ˆä»¥`0`å¼€å¤´ï¼‰æˆ–åå…­è¿›åˆ¶ï¼ˆä»¥`0x`æˆ–`0X`å¼€å¤´ï¼‰å½¢å¼
    ```
    20              // decï¼Œint
    -42             // decï¼Œint
    42ULL           // decï¼Œunsigned long long
    024             // octï¼Œint
    0x1a            // hexï¼Œint
    0X1A            // hexï¼Œint
    ```
    - é»˜è®¤ï¼ˆæ— åç¼€ï¼‰æƒ…å†µä¸‹
        - åè¿›åˆ¶å­—é¢å€¼ä¸º`int`ã€`long`å’Œ`long long`ä¸­èƒ½å®¹çº³è¯¥æ•°å€¼çš„å°ºå¯¸æœ€å°è€…
            - åè¿›åˆ¶å­—é¢å€¼**ä¸ä¼š**æ˜¯è´Ÿæ•°ã€‚ä¾‹å¦‚`-42`ä¸­çš„`-`å¹¶ä¸ç®—åœ¨å­—é¢å€¼é‡Œé¢ï¼Œå…¶ä½œç”¨åªæ˜¯å¯¹å­—é¢å€¼`42`å–ç›¸åæ•°
        - å…«è¿›åˆ¶å’Œåå…­è¿›åˆ¶å­—é¢å€¼ä¸º`int`ã€`unsigned int`ã€`long`ã€`unsigned long`ã€`long long`å’Œ`unsigned long long`ä¸­èƒ½å®¹çº³è¯¥æ•°å€¼çš„å°ºå¯¸æœ€å°è€… 
    - å¯é€‰åç¼€
        - `u`ï¼Œ`U`ï¼š *æœ€å°* åŒ¹é…`unsigned`ã€‚å¯ä¸`L`ã€`LL`æ­é…ä½¿ç”¨
        - `l`ï¼Œ`L`ï¼š *æœ€å°* åŒ¹é…`long`
        - `ll`ï¼Œ`LL`ï¼š *æœ€å°* åŒ¹é…`long long`
        - è¿™äº›åç¼€éƒ½è¯¥ä½¿ç”¨ *å¤§å†™* ç‰ˆæœ¬ï¼Œå› ä¸ºå°å†™çš„`l`å¤ªå®¹æ˜“å’Œ`1`æ··äº†
- *æµ®ç‚¹æ•°* 
    - å†™ä½œä¸€ä¸ªå°æ•°æˆ–ä»¥ç§‘å­¦è®¡æ•°æ³•è¡¨ç¤ºçš„æŒ‡æ•°ï¼Œå…¶ä¸­æŒ‡æ•°éƒ¨åˆ†ç”¨`e`æˆ–`E`æ ‡è¯†
    ```
    3.14159         // double
    3.14159E0       // double
    3.14159L        // long double
    0.              // double
    0e0             // double
    1E-3F           // float
    .001            // double
    ```
    - é»˜è®¤ï¼ˆæ— åç¼€ï¼‰æƒ…å†µä¸‹ä¸º`double`
    - å¯é€‰åç¼€
        - `f`ï¼Œ`F`ï¼šåŒ¹é…`float`
        - `l`ï¼Œ`L`ï¼šåŒ¹é…`long double`
- *å­—ç¬¦* å’Œ *å­—ç¬¦ä¸²* 
    - ç”±å•å¼•å·`''`æ‹¬èµ·æ¥çš„æ˜¯å­—ç¬¦ï¼ŒåŒå¼•å·`""`æ‹¬èµ·æ¥çš„æ˜¯å­—ç¬¦ä¸²
    ```
    'a'             // char
    "Hello World!"  // string literal (const char [])
    L'a'            // wchar_t
    u8"hi!"         // UTF-8 string literal
    ```
    - å¯é€‰å‰ç¼€
        - `u`ï¼š`Unicode 16`å­—ç¬¦ï¼ŒåŒ¹é…`char16_t`
        - `U`ï¼š`Unicode 32`å­—ç¬¦ï¼ŒåŒ¹é…`char32_t`
        - `L`ï¼šå®½å­—ç¬¦ï¼ŒåŒ¹é…`wchar_t`
        - `u8`ï¼š`UTF-8`å­—ç¬¦ï¼ˆä»…ç”¨äºå­—ç¬¦ä¸²å­—é¢å€¼ï¼‰ï¼ŒåŒ¹é…`char`
    - å­—ç¬¦ä¸²å­—é¢å€¼å®é™…æ˜¯å¸¸å­—ç¬¦æ•°ç»„ï¼Œç¼–è¯‘å™¨è‡ªåŠ¨åœ¨æœ«å°¾æ·»åŠ ç©ºå­—ç¬¦`'\0'`ä½œä¸ºç»“å°¾
    ```
    strlen("12")   == 3
    strlen("12\0") == 3
    ```
    - å¦‚æœä¸¤ä¸ªå­—ç¬¦ä¸²å­—é¢å€¼ä½ç½®ç´§é‚»ä¸”ä»…ç”± *ç©ºæ ¼* ã€ *ç¼©è¿›* ä»¥åŠ *æ¢è¡Œç¬¦* åˆ†éš”ï¼Œåˆ™å®ƒä»¬æ˜¯ *ä¸€ä¸ªæ•´ä½“* 
        - ä¹¦å†™çš„å­—ç¬¦ä¸²å­—é¢å€¼è¾ƒé•¿æ—¶ï¼Œä¸å¦¨åˆ†å¼€ä¹¦å†™
    ```
    std::cout << "a really, really long string literal "
                 "that spans two lines"                  << std::endl;
    ```
    - è½¬ä¹‰åºåˆ—
        - è½¬ä¹‰åºåˆ—å‡ä»¥`\`å¼€å§‹
            - `'\n'`ï¼šæ¢è¡Œç¬¦
            - `'\r'`ï¼šå›è½¦ç¬¦
            - `'\t'`ï¼šæ¨ªå‘åˆ¶è¡¨ç¬¦
            - `'\v'`ï¼šçºµå‘åˆ¶è¡¨ç¬¦
            - `'\b'`ï¼šé€€æ ¼ç¬¦
            - `'\f'`ï¼šè¿›çº¸ç¬¦
            - `'\a'`ï¼šæŠ¥è­¦ï¼ˆå“é“ƒï¼‰ç¬¦
            - `'\"'`ï¼šåŒå¼•å·
            - `'\''`ï¼šå•å¼•å·
            - `'\\'`ï¼šåæ–œæ 
            - `'\?'`ï¼šé—®å·
        - æ³›åŒ–çš„è½¬ä¹‰åºåˆ—
            - `'\0'`ï¼šç©ºå­—ç¬¦
            - `'\7'`ï¼šå“é“ƒ
            - `'\12'`ï¼šæ¢è¡Œ
            - `'\40'`ï¼šç©ºæ ¼
            - `'\115'`ï¼Œ`'\x4d'`ï¼š`'M'`

### ğŸŒ± ä½œç”¨åŸŸï¼ˆscopeï¼‰

- æ ¹æ®å˜é‡çš„ *å®šä¹‰ä½ç½®* å’Œ *ç”Ÿå‘½å‘¨æœŸ* ï¼Œ`C++`çš„å˜é‡å…·æœ‰ä¸åŒçš„ *ä½œç”¨åŸŸ* ï¼Œå…±åˆ†ä¸ºä»¥ä¸‹å‡ ç±» 
    - å…¨å±€ä½œç”¨åŸŸï¼ˆglobal scopeï¼Œè·¨æ–‡ä»¶çš„å…¨å±€ä½œç”¨åŸŸï¼‰
    - æ–‡ä»¶ä½œç”¨åŸŸï¼ˆä»…é™è‡ªå·±æ‰€åœ¨æ–‡ä»¶å†…çš„â€œå…¨å±€â€ä½œç”¨åŸŸï¼‰
    - å±€éƒ¨ä½œç”¨åŸŸ
        - å—ä½œç”¨åŸŸï¼ˆblock scopeï¼‰
            - æ¯”å¦‚
                - åˆ†æ”¯æˆ–å¾ªç¯è¯­å¥ä½“
                - å‡½æ•°ä½“
                - å…¶ä»–è¯­å¥å—ï¼ˆç›´æ¥ä¸€ä¸ªå¤§æ‹¬å·æ‹¬èµ·æ¥ï¼‰
            - å—**ä¸ä»¥**åˆ†å·ä½œä¸ºç»“æŸ
        - ç±»ä½œç”¨åŸŸ
        - å‘½åç©ºé—´ä½œç”¨åŸŸ
- å†…éƒ¨ä½œç”¨åŸŸï¼ˆinner scopeï¼‰ä¼š *è¦†ç›–* å¤–éƒ¨ä½œç”¨åŸŸï¼ˆouter scopeï¼‰çš„åŒåå˜é‡
- ä»ä½œç”¨åŸŸçœ‹å˜é‡
    - *å…¨å±€éé™æ€å˜é‡* 
        - å³å®šä¹‰äºæ‰€æœ‰å‡½æ•°ä¹‹å¤–çš„éé™æ€å˜é‡
        - å…·æœ‰å…¨å±€ä½œç”¨åŸŸï¼ˆè·¨æ–‡ä»¶ï¼‰
            - åªéœ€åœ¨ä¸€ä¸ªæºæ–‡ä»¶ä¸­å®šä¹‰ï¼Œå°±å¯ä»¥ä½œç”¨äºæ‰€æœ‰çš„æºæ–‡ä»¶
            - å½“å…¶ä»–ä¸åŒ…å«å…¨å±€å˜é‡å®šä¹‰çš„æºæ–‡ä»¶ä¸­ï¼Œä½¿ç”¨å‰éœ€ç”¨`extern`å†æ¬¡å£°æ˜è¿™ä¸ªå…¨å±€å˜é‡
    - *å…¨å±€é™æ€å˜é‡* 
        - å…·æœ‰æ–‡ä»¶ä½œç”¨åŸŸï¼ˆ**ä¸**è·¨æ–‡ä»¶ï¼‰
            - å¦‚æœç¨‹åºåŒ…å«å¤šä¸ªæ–‡ä»¶ï¼Œåˆ™ä»…ä½œç”¨äºå®šä¹‰å®ƒçš„æ–‡ä»¶ï¼Œä¸èƒ½ä½œç”¨äºå…¶å®ƒæ–‡ä»¶
            - è¿™æ ·å³ä½¿ä¸¤ä¸ªä¸åŒçš„æºæ–‡ä»¶éƒ½å®šä¹‰äº†ç›¸åŒåå­—çš„é™æ€å…¨å±€å˜é‡ï¼Œå®ƒä»¬ä¹Ÿæ˜¯ *ä¸åŒ* çš„å˜é‡
                - è¿™ä¸€ç‚¹å’Œæ²¡æœ‰åŠ `extern`çš„å…¨å±€å¸¸é‡ä¸€æ ·        
    - *å±€éƒ¨éé™æ€å˜é‡* 
        - å…·æœ‰å±€éƒ¨ä½œç”¨åŸŸï¼ŒåŒ…æ‹¬
            - å‡½æ•°ä½“å†…å®šä¹‰çš„éé™æ€å˜é‡
            - å—è¯­å¥å†…å®šä¹‰çš„éé™æ€å˜é‡
            - å‡½æ•°å½¢å‚
        - æ˜¯ *è‡ªåŠ¨å¯¹è±¡* ï¼ˆautomatic objectï¼‰
            - æ¯å½“å‡½æ•°æ§åˆ¶è·¯å¾„ç»è¿‡å˜é‡å®šä¹‰è¯­å¥æ—¶åˆ›å»ºè¯¥å¯¹è±¡å¹¶åˆå§‹åŒ–ï¼Œå½“åˆ°è¾¾å®šä¹‰æ‰€åœ¨å—æœ«å°¾æ—¶é”€æ¯ä¹‹
            - è‡ªç„¶ï¼Œåªå­˜åœ¨äºå—æ‰§è¡ŒæœŸé—´
    - *å±€éƒ¨é™æ€å˜é‡* 
        - ä¹Ÿå…·æœ‰å±€éƒ¨ä½œç”¨åŸŸ
        - æ˜¯ *å±€éƒ¨é™æ€å¯¹è±¡* ï¼ˆlocal static objectï¼‰
            - åœ¨ç¨‹åºçš„æ‰§è¡Œè·¯å¾„ç¬¬ä¸€æ¬¡ç»è¿‡å¯¹è±¡å®šä¹‰è¯­å¥æ—¶åˆå§‹åŒ–ï¼Œå¹¶ä¸”ç›´åˆ°æ•´ä¸ªç¨‹åºç»ˆæ­¢æ—¶æ‰è¢«é”€æ¯ã€‚
            - åœ¨æ­¤æœŸé—´ï¼Œå¯¹è±¡æ‰€åœ¨å‡½æ•°æ‰§è¡Œå®Œæ¯•ä¹Ÿä¸ä¼šå¯¹å®ƒæœ‰å½±å“ã€‚
            - å¦‚æ²¡æœ‰æ˜¾å¼åˆå§‹åŒ–ï¼Œåˆ™ä¼šæ‰§è¡Œéšå¼åˆå§‹åŒ–ï¼ˆå†…ç½®ç±»å‹éšå¼åˆå§‹åŒ–ä¸º`0`ï¼‰
        ```
        size_t countCalls()
        {
            static size_t ctr = 0;  // è°ƒç”¨ç»“æŸåè¿™ä¸ªå€¼ä¾ç„¶æœ‰æ•ˆï¼Œä¸”åˆå§‹åŒ–ä¼šä¸”åªä¼šåœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶æ‰§è¡Œä¸€æ¬¡ã€‚
                                    // å†…ç½®ç±»å‹çš„å±€éƒ¨é™æ€å¯¹è±¡éšå¼åˆå§‹åŒ–ä¸º0ï¼Œå³ï¼šè¿™é‡Œçš„æ˜¾å¼åˆå§‹åŒ–ä¸º0å…¶å®æ˜¯ä¸å¿…è¦çš„ã€‚
            return ++ctr;
        }
        ```
        - å’Œå…¨å±€å˜é‡çš„åŒºåˆ«
            - å…¨å±€å˜é‡å¯¹æ‰€æœ‰çš„å‡½æ•°å¯è§çš„
            - é™æ€å±€éƒ¨å˜é‡åªå¯¹å®šä¹‰è‡ªå·±çš„å‡½æ•°å¯è§
- *é™æ€å‡½æ•°* 
    - å‡½æ•°çš„è¿”å›å€¼ç±»å‹å‰åŠ ä¸Š`static`å…³é”®å­—
    - åªåœ¨å£°æ˜å®ƒçš„æ–‡ä»¶å½“ä¸­å¯è§ï¼Œ**ä¸èƒ½**è¢«å…¶å®ƒæ–‡ä»¶ä½¿ç”¨

### ğŸŒ± åˆå§‹åŒ–

#### æ˜¾å¼åˆå§‹åŒ–å’Œéšæ€§åˆå§‹åŒ–

- *æ˜¾å¼åˆå§‹åŒ–*
    - `C`é£æ ¼æ˜¾å¼åˆå§‹åŒ–
    ```
    int a = 1;
    int b(1);
    ```
    - *åˆ—è¡¨åˆå§‹åŒ–* ã€‚å¦‚ä¼šæŸå¤±ç²¾åº¦ï¼Œåˆ™**CE**
    ```
    int c = {1};
    int d{1};
        
    int e = {3.14};  // error: type 'double' can not be narrowed down to 'int' in initializer list
    int f{3.14};     // error: type 'double' can not be narrowed down to 'int' in initializer list
    ```
- *éšå¼åˆå§‹åŒ–* ï¼šæœªæ˜¾å¼åˆå§‹åŒ–çš„å˜é‡æŒ‰ç…§å¦‚ä¸‹è§„åˆ™æ‰§è¡Œéšå¼åˆå§‹åŒ–
    - å†…ç½®ç±»å‹
        - *å…¨å±€å˜é‡* ï¼šå†…ç½®å˜é‡ä¸”åœ¨å‡½æ•°ä½“ä¹‹å¤–ï¼Œéšå¼åˆå§‹åŒ–ä¸º`0`
        - *å±€éƒ¨é™æ€å˜é‡* ï¼šå‡½æ•°ä½“å†…çš„é™æ€å˜é‡ï¼Œéšå¼åˆå§‹åŒ–ä¸º`0`
        - *å±€éƒ¨éé™æ€å˜é‡* ï¼šå†…ç½®å˜é‡ä¸”åœ¨å‡½æ•°ä½“ä¹‹å†…ï¼Œ**æ— **éšå¼åˆå§‹åŒ–
            - æœªåˆå§‹åŒ–çš„å†…ç½®ç±»å‹å±€éƒ¨å˜é‡å°†äº§ç”Ÿ *æœªå®šä¹‰* çš„å€¼
    - è‡ªå®šä¹‰å¯¹è±¡
        - ç”±å…·ä½“çš„ç±»å†³å®š => 7.5.3

#### æ‹·è´åˆå§‹åŒ–å’Œç›´æ¥åˆå§‹åŒ–

- å¦‚æœåˆå§‹åŒ–æ—¶ä½¿ç”¨äº†ç­‰å·ï¼Œåˆ™æ˜¯ *æ‹·è´åˆå§‹åŒ–* ï¼ˆç”Ÿæˆå¹¶ç›´æ¥åˆå§‹åŒ–ä¸´æ—¶å³å€¼å¯¹è±¡ï¼Œå†å°†ä¸´æ—¶å¯¹è±¡æ‹·è´åˆ°å·¦å€¼ï¼‰ï¼Œæœ‰æ€§èƒ½æŸå¤±
```
std::string s = std::string("hehe"); 

// å®é™…æ‰§è¡Œæ—¶ç­‰ä»·äºï¼š
std::string tmp("hehe"); 
std::string s = tmp; 
```
- å¦‚ä¸ä½¿ç”¨ç­‰å·ï¼Œåˆ™æ˜¯ *ç›´æ¥åˆå§‹åŒ–* 

### ğŸŒ± `extern`ä¿®é¥°ç¬¦

#### å£°æ˜å’Œå®šä¹‰

```
int a;             // è¿™å…¶å®æ˜¯å£°æ˜å¹¶å®šä¹‰äº†å˜é‡a
extern int a;      // è¿™æ‰æ˜¯ä»…ä»…å£°æ˜è€Œä¸å®šä¹‰
extern int a = 1;  // è¿™æ˜¯å£°æ˜å¹¶å®šä¹‰äº†å˜é‡aå¹¶åˆå§‹åŒ–ä¸º1ã€‚
                   // ä»»ä½•åŒ…å«æ˜¾å¼åˆå§‹åŒ–çš„å£°æ˜å³æˆä¸ºå®šä¹‰ï¼Œå¦‚æœ‰externåˆ™å…¶ä½œç”¨ä¼šè¢«æŠµæ¶ˆ
```

#### `const`å¸¸é‡ä¸è®ºæ˜¯å£°æ˜è¿˜æ˜¯å®šä¹‰éƒ½æ·»åŠ `extern`ä¿®é¥°ç¬¦

- é»˜è®¤çŠ¶æ€ä¸‹ï¼Œ`const`å¯¹è±¡ä¸ºæ–‡ä»¶ä½œç”¨åŸŸï¼ˆå³ï¼šä»…åœ¨æ–‡ä»¶å†…æœ‰æ•ˆï¼‰
- å¦‚æœæƒ³åœ¨å¤šä¸ªæ–‡ä»¶ä¹‹é—´å…±äº«`const`å¯¹è±¡ï¼Œåˆ™å¿…é¡»åœ¨å®šä¹‰çš„å¯¹è±¡ä¹‹å‰æ·»åŠ `extern`å…³é”®å­—
```
extern const int BUF_SIZE = fcn();  // globals.cpp
extern const int BUF_SIZE;          // globals.h
extern const int BUF_SIZE;          // sth.h ï¼ˆå…¶ä»–è¦ç”¨åˆ°`BUF_SIZE`çš„å¤´æ–‡ä»¶ï¼‰
```
ç¼–è¯‘å™¨åœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­ä¼šæŠŠæ‰€æœ‰çš„`const`å˜é‡éƒ½æ›¿æ¢æˆç›¸åº”çš„å­—é¢å€¼ã€‚
ä¸ºäº†æ‰§è¡Œä¸Šè¿°æ›¿æ¢ï¼Œç¼–è¯‘å™¨å¿…é¡»çŸ¥é“å˜é‡çš„åˆå§‹å€¼ã€‚
å¦‚æœç¨‹åºåŒ…å«å¤šä¸ªæ–‡ä»¶ï¼Œåˆ™æ¯ä¸ªç”¨äº†`const`å¯¹è±¡çš„æ–‡ä»¶éƒ½å¿…é¡»å¾—èƒ½è®¿é—®åˆ°å®ƒçš„åˆå§‹å€¼æ‰è¡Œã€‚
è¦åšåˆ°è¿™ä¸€ç‚¹ï¼Œå°±å¿…é¡»åœ¨æ¯ä¸€ä¸ªç”¨åˆ°å˜é‡çš„æ–‡ä»¶ä¹‹ä¸­éƒ½æœ‰å®ƒçš„å®šä¹‰ã€‚
ä¸ºäº†æ”¯æŒè¿™ä¸€ç”¨æ³•ï¼ŒåŒæ—¶é¿å…å¯¹åŒä¸€å˜é‡çš„é‡å¤å®šä¹‰ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œ`const`å¯¹è±¡è¢«è®¾å®šä¸ºä»…åœ¨æ–‡ä»¶å†…æœ‰æ•ˆã€‚
å½“å¤šä¸ªæ–‡ä»¶ä¸­å‡ºç°äº†åŒåçš„`const`å˜é‡æ—¶ï¼Œå…¶å®ç­‰åŒäºåœ¨ä¸åŒæ–‡ä»¶ä¸­åˆ†åˆ«å®šä¹‰äº†**ç‹¬ç«‹çš„**å˜é‡ã€‚

å¦‚æœå¸Œæœ›`const`å¯¹è±¡åªåœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­å®šä¹‰ä¸€æ¬¡ï¼Œè€Œåœ¨å¤šä¸ªæ–‡ä»¶ä¸­å£°æ˜å¹¶ä½¿ç”¨å®ƒï¼Œåˆ™éœ€é‡‡ç”¨ä¸Šè¿°æ“ä½œã€‚

### ğŸŒ± å¤åˆç±»å‹ï¼ˆæŒ‡é’ˆã€å¼•ç”¨ï¼‰

- æŒ‡é’ˆ`*`ä»¥åŠå¼•ç”¨`&`åªä»å±äºæŸä¸ªå£°æ˜ç¬¦ï¼Œè€Œä¸æ˜¯åŸºæœ¬æ•°æ®ç±»å‹çš„ä¸€éƒ¨åˆ†
- æŒ‡é’ˆè§£å¼•ç”¨çš„ç»“æœæ˜¯è¢«å¼•ç”¨å¯¹è±¡çš„å·¦å€¼å¼•ç”¨
- æŒ‡é’ˆæˆ–å¼•ç”¨çš„ç±»å‹å¿…é¡»ä¸å…¶æ‰€å¼•ç”¨çš„å¯¹è±¡çš„**ç±»å‹ä¸¥æ ¼ä¸€è‡´**ï¼ˆé™¤ä¸‹ä¸€æ¡çš„2ä¸ªä¾‹å¤–ï¼‰ï¼Œå³
    - æŒ‡é’ˆåªèƒ½ç”¨åŒç±»å‹çš„å…¶ä»–æŒ‡é’ˆï¼ˆåŒ…æ‹¬å­—é¢é‡æˆ–å¯¹è±¡å¼ºåˆ¶è½¬æ¢æˆçš„æŒ‡é’ˆï¼Œä»¥åŠå–å€¼ç¬¦è·å–çš„åœ°å€ï¼‰ï¼Œæˆ–è€…`NULL`ã€`nullptr`èµ‹å€¼
    - `double`å­—é¢é‡æˆ–å˜é‡éƒ½ä¸èƒ½å¼ºè½¬æˆæŒ‡é’ˆ
    - å¼•ç”¨åªèƒ½ç»‘å®šåˆ°åŒç±»å‹çš„å¯¹è±¡ä¸Š
    - å¯¹äºå¸¸é‡ï¼Œåªèƒ½ç»‘å®šå¸¸é‡æŒ‡é’ˆæˆ–å¸¸å¼•ç”¨ï¼Œä¸èƒ½ç»‘å®šæ™®é€šæŒ‡é’ˆæˆ–æ™®é€šå¼•ç”¨
- ä¸Šä¸€æ¡æœ‰2ä¸ªä¾‹å¤–
    - æŒ‡é’ˆï¼šå¸¸é‡æŒ‡é’ˆæŒ‡å‘éå¸¸é‡å¯¹è±¡ï¼›åŸºç±»æŒ‡é’ˆæŒ‡å‘æ´¾ç”Ÿç±»å¯¹è±¡
    - å¼•ç”¨ï¼šå¸¸å¼•ç”¨ç»‘å®šåˆ°ä»»ä½•èƒ½è½¬åŒ–ä¸ºæœ¬ç±»å‹å¸¸å¼•ç”¨çš„å¯¹è±¡ï¼ˆåŒ…æ‹¬å­—é¢å€¼ï¼‰ä¸Šï¼›åŸºç±»å¼•ç”¨ç»‘å®šåˆ°æ´¾ç”Ÿç±»å¯¹è±¡ä¸Š
        - **å¸¸å¼•ç”¨å¯ä»¥ç»‘å®šåœ¨ã€å…¶å®ƒç±»å‹ã€‘çš„ã€å³å€¼ã€‘ä¸Š**ã€‚å°¤å…¶ï¼Œå…è®¸ä¸ºä¸€ä¸ªå¸¸å¼•ç”¨ç»‘å®š
            - éå¸¸é‡çš„å¯¹è±¡
            - å­—é¢å€¼
            - ä¸€èˆ¬è¡¨è¾¾å¼
```
double i = 4.2;
const int & r1 = i;      // æ­£ç¡®ï¼šwe can bind a const int& to a plain int object
const int & r2 = 4.2;    // æ­£ç¡®ï¼šr1 is a reference to const
const int & r3 = i * 2;  // æ­£ç¡®ï¼šr3 is a reference to const
int & r4 = i * 2;        // é”™è¯¯ï¼šr4 is a plain reference, not const reference

// æ³¨ï¼šæ‰§è¡Œå¦‚ä¸‹ä»£ç æ—¶ï¼š

double pi = 3.1415926;  
const int & a = pi;      // ok

// å®é™…ä¸Šç¼–è¯‘å™¨å¹²äº†è¿™ä¹ˆä»¶äº‹ï¼š

int tmp = pi;
const int & a = tmp;

// å¦‚æœä¸æ˜¯å¸¸é‡å¼•ç”¨ï¼Œæ”¹çš„å°±ä¸æ˜¯piè€Œæ˜¯ä¸´æ—¶é‡tmpï¼Œå®¹æ˜“é€ æˆäººç¥¸ï¼Œå› `C++ç›´æ¥è§„å®šéå¸¸é‡å¼•ç”¨ä¸èƒ½ç»‘å®šç»™ä¸´æ—¶é‡ã€‚
```
- *å¸¸é‡æŒ‡é’ˆ* ï¼ˆæŒ‡é’ˆæŒ‡å‘å¸¸é‡ï¼‰å’Œ *æŒ‡é’ˆå¸¸é‡* ï¼ˆæŒ‡é’ˆæœ¬èº«æ˜¯å¸¸é‡ï¼‰ä¸ä¸€æ ·
```
int num = 1;  
const int * p1 = &num;        // æŒ‡å‘`const int`çš„æŒ‡é’ˆã€‚ä¸èƒ½ç”¨p1ä¿®æ”¹numçš„å€¼ï¼Œä½†å¯ä»¥è®©p1æŒ‡å‘åˆ«çš„`(const) int`å˜é‡ã€‚
int * const p2 = &num;        // æŒ‡å‘`int`çš„å¸¸æŒ‡é’ˆã€‚ä¸èƒ½è®©p1æŒ‡å‘åˆ«çš„`int`å˜é‡ï¼Œä½†å¯ä»¥ç”¨p1ä¿®æ”¹numçš„å€¼ã€‚
const int * const p2 = &num;  // æŒ‡å‘`const int`çš„å¸¸æŒ‡é’ˆã€‚æ—¢ä¸èƒ½ç”¨p1ä¿®æ”¹numçš„å€¼ï¼Œä¹Ÿä¸å¯ä»¥è®©p1æŒ‡å‘åˆ«çš„`int`å˜é‡ã€‚
```
- *é¡¶å±‚* `const`å’Œ *åº•å±‚* `const`
    - *é¡¶å±‚* `const`ï¼ˆTop-level `const`ï¼‰ï¼šä»»æ„çš„å¯¹è±¡æ˜¯å¸¸é‡
    - *åº•å±‚* `const`ï¼ˆLow-level `const`ï¼‰ï¼šä»…é™æŒ‡é’ˆæˆ–å¼•ç”¨ã€‚æŒ‡å‘çš„é‚£ä¸ªå¯¹è±¡æœ¬èº«æ˜¯å¸¸é‡
        - æ³¨æ„ï¼Œå¼•ç”¨ä¸€æ—¦ç»‘å®šå°±æ°¸è¿œä¸èƒ½æ”¹äº†ï¼Œå› æ­¤æ™®é€šå¼•ç”¨ä»¥åŠå¸¸å¼•ç”¨æœ¬èº«éƒ½è‡ªå¸¦ *é¡¶å±‚* `const`
        - å¸¸é‡å¼•ç”¨æ°¸è¿œéƒ½æ˜¯ *åº•å±‚* `const`
        - å¯¹å¸¸é‡å¯¹è±¡å–åœ°å€è·å–çš„æŒ‡é’ˆæ˜¯ *åº•å±‚* `const`
        - éå¸¸é‡å¼•ç”¨**ä¸èƒ½**ç»‘å®šåˆ°å¸¸é‡å¯¹è±¡ä¸Š
    ```
    int i = 0;
    int * const p1 = &i;        // é¡¶å±‚const
    const int ci = 42;          // é¡¶å±‚const
    const int * p2 = &ci;       // åº•å±‚const
    const int * const p3 = p2;  // ç¬¬ä¸€ä¸ªconstä¸ºåº•å±‚ï¼Œç¬¬äºŒä¸ªä¸ºé¡¶å±‚
    const int & r = ci;         // å¸¸é‡å¼•ç”¨æ°¸è¿œéƒ½æ˜¯åº•å±‚const
    ```
    - é™„èµ ä¸€æ¡çŸ¥ä¹é«˜ç¥¨å›ç­”ï¼š *é¡¶å±‚* å’Œ *åº•å±‚ * çš„ç¿»è¯‘å¾ˆå®¹æ˜“è®©äººè¯¯è§£ä¸ºå°±åªæœ‰ä¸¤å±‚ï¼Œå®é™…ä¸Šå½“ç„¶æ˜¯ä¸æ˜¯çš„ã€‚é¦–å…ˆæˆ‘ä»¬å‡è®¾æœ‰è¿™æ ·çš„ä»£ç 
    ```
    template<typename T> using Const = const T;
    template<typename T> using Ptr = T *;

    const int *** const shit = nullptr;
    
    // è¦æ€ä¹ˆçœ‹å‘¢ï¼Ÿå¾ˆç®€å•ï¼Œä¸è¦ç”¨`const`å’Œ`*`ï¼Œç”¨`Const`å’Œ`Ptr`æ¥è¡¨è¾¾ï¼Œé©¬ä¸Šæ˜ç™½ï¼š
    Const<Ptr<Ptr<Ptr<Const<int>>>>> shit = nullptr;
    ```

### ğŸŒ± å¤„ç†ç±»å‹

#### ç±»å‹åˆ«å

```
typedef int * intptr;
using intptr2 = int *;

int a = 1;
const intptr p = &a;             // "const (int *)", i.e. `int * const`. NOT `const int *`!!!
const intptr2 p2 = &a, p3 = &a;  // æ³¨æ„è¿™é‡Œp3å·²ç»æ˜¯æŒ‡é’ˆäº†ï¼Œä¸éœ€è¦å†åŠ *
```

#### `auto`ç±»å‹è¯´æ˜ç¬¦

- `auto`å®šä¹‰çš„å˜é‡å¿…é¡»æœ‰åˆå§‹å€¼
    - ç¼–è¯‘å™¨é€šè¿‡åˆå§‹å€¼æ¥æ¨ç®—ç±»å‹
- `auto`ä¸€å¥è¯å®šä¹‰å¤šä¸ªå˜é‡æ—¶ï¼Œæ‰€æœ‰å˜é‡ç±»å‹å¿…é¡»ä¸€æ ·
```
auto a = 1, *b = &a;     // æ­£ç¡®ï¼Œaä¸ºint, bä¸ºint *
auto sz = 0, pi = 3.14;  // é”™è¯¯ï¼Œszå’Œpiç±»å‹ä¸åŒ
```
- å¤åˆç±»å‹ã€å¸¸é‡å’Œ`auto`
    - å¯¹äºå¼•ç”¨ï¼Œ`auto`æ¨å¯¼ä¸ºè¢«å¼•ç”¨å¯¹è±¡çš„ç±»å‹ï¼ˆä½¿ç”¨å¼•ç”¨å®é™…ä¸Šæ˜¯ä½¿ç”¨è¢«å¼•ç”¨çš„å¯¹è±¡ï¼Œç‰¹åˆ«æ˜¯å¼•ç”¨è¢«ç”¨ä½œåˆå§‹å€¼æ—¶ï¼Œå‚ä¸åˆå§‹åŒ–çš„æ˜¯è¢«å¼•ç”¨å¯¹è±¡çš„å€¼ï¼‰
    ```
    int a = 0, &r = i;
    auto b = r;                  // bä¸ºintï¼Œè€Œä¸æ˜¯int &
    ```
    - å¯¹äº`const`ï¼š`auto`ä¼šå¿½ç•¥é¡¶å±‚`const`
    ```
    int i = 1;
    const int ci = i, &cr = ci;
    auto b = ci;                 // bä¸ºintï¼ˆciä¸ºé¡¶å±‚constï¼‰
    auto c = cr;                 // cä¸ºintï¼ˆcrä¸ºciçš„åˆ«å, ciæœ¬èº«æ˜¯é¡¶å±‚constï¼‰
    auto d = &i;                 // dä¸ºint *ï¼ˆ&iä¸ºconst int *ï¼Œï¼‰
    auto e = &ci;                // eä¸ºconst int *ï¼ˆå¯¹å¸¸é‡å¯¹è±¡å–åœ°å€æ˜¯åº•å±‚constï¼‰
    ```
    - å¦‚æœå¸Œæœ›`auto`æ¨æ–­å‡ºå¼•ç”¨æˆ–è€…é¡¶å±‚å¸¸é‡ï¼Œåˆ™å£°æ˜`auto`æ—¶å¿…é¡»åŠ ä¸Šç›¸åº”çš„æè¿°ç¬¦
    ```
    const auto f = ci;           // fä¸ºconst int
    auto & g = ci;               // gä¸ºconst int &
    auto & h = 42;               // é”™è¯¯ï¼šä¸èƒ½ä¸ºéå¸¸é‡å¼•ç”¨ç»‘å®šå­—é¢å€¼
    const auto & j = 42;         // æ­£ç¡®ï¼šå¯ä»¥ä¸ºå¸¸é‡å¼•ç”¨ç»‘å®šå­—é¢å€¼
    ```
    - `auto`ä¸€å¥è¯å®šä¹‰å¤šä¸ªå˜é‡æ—¶ï¼Œæ‰€æœ‰å˜é‡ç±»å‹å¿…é¡»ä¸€æ ·ã€‚æ³¨æ„`*`å’Œ`*`æ˜¯ä»å±äºå£°æ˜ç¬¦çš„ï¼Œè€Œä¸æ˜¯åŸºæœ¬æ•°æ®ç±»å‹çš„ä¸€éƒ¨åˆ†
    ```
    auto k = ci, &l = ci;        // kä¸ºintï¼Œlä¸ºint &
    auto & m = ci, *p2 = &ci;    // mä¸ºconst int &ï¼Œp2ä¸ºconst int *
    auto & n = i, *p2 = &ci;     // é”™è¯¯ï¼šiçš„ç±»å‹ä¸ºintï¼Œè€Œ&ciçš„ç±»å‹ä¸ºconst int
    ```

#### `decltype`ç±»å‹æŒ‡ç¤ºç¬¦

- `decltype(expr)`åœ¨ä¸å¯¹`expr`è¿›è¡Œæ±‚å€¼çš„æƒ…å†µä¸‹åˆ†æå¹¶è¿”å›`expr`çš„æ•°æ®ç±»å‹
```
decltype(f()) a = b;         // açš„ç±»å‹å°±æ˜¯å‡½æ•°fçš„è¿”å›å€¼ç±»å‹ã€‚åŒæ—¶ï¼Œè¿™å¥è¯å¹¶ä¸ä¼šè°ƒç”¨f()
```
- `decltype(expr)`ä¼šåŸæ ·ä¿ç•™å¼•ç”¨ä»¥åŠé¡¶å±‚`const`
    - å¼•ç”¨ä»æ¥éƒ½æ˜¯ä½œä¸ºè¢«å¼•ç”¨å¯¹è±¡çš„åŒä¹‰è¯å‡ºç°ï¼ˆæ¯”å¦‚`auto`å°±ä¸èƒ½è‡ªåŠ¨æ¨æ–­å‡ºå¼•ç”¨ï¼‰ï¼Œå”¯ä¸€ä¾‹å¤–æ˜¯`decltype`
    - è¿™å¾ˆç¬¦åˆ`decltype`ä¸€è¯åœ¨è‡ªç„¶è¯­è¨€ä¸­çš„è¯­ä¹‰ï¼Œå¿…é¡»åŸæ ·è½¬å‘äººå®¶æœ¬æ¥æ˜¯ä»€ä¹ˆ
```
const int ci = 0, &cj = ci;
decltype(ci) x = 0;          // xä¸ºconst int
decltype(cj) y = x;          // yä¸ºconst int &
decltype(cj) z;              // é”™è¯¯ï¼šzä¸ºconst int &ï¼Œå¿…é¡»è¢«åˆå§‹åŒ–
```
- `decltype((...))`ï¼ˆåŒå±‚æ‹¬å·ï¼‰çš„ç»“æœæ°¸è¿œæ˜¯å¼•ç”¨ï¼Œè€Œ`decltype(...)`ï¼ˆå•å±‚æ‹¬å·ï¼‰å½“ä¸”ä»…å½“`...`æ˜¯å¼•ç”¨ç±»å‹æ—¶æ‰æ˜¯å¼•ç”¨

### ğŸŒ± å·¦å€¼å’Œå³å€¼

- èµ‹å€¼è¿ç®—ç¬¦`a = b`ä¸­ï¼Œ`a`éœ€æ˜¯ï¼ˆéå¸¸é‡ï¼‰å·¦å€¼ï¼Œè¿”å›ç»“æœä¹Ÿæ˜¯**å·¦**å€¼
- å–åœ°å€ç¬¦`&a`ä¸­ï¼Œ`a`éœ€æ˜¯å·¦å€¼ï¼Œè¿”å›æŒ‡å‘`a`çš„å³å€¼æŒ‡é’ˆ
- è§£å¼•ç”¨è¿ç®—ç¬¦`*a`å’Œä¸‹æ ‡è¿ç®—ç¬¦`a[i]`çš„è¿”å›ç»“æœå‡ä¸º**å·¦**å€¼
- è‡ªå¢è‡ªå‡è¿ç®—ç¬¦`a++`ç­‰ä¸­ï¼Œ`a`éœ€æ˜¯å·¦å€¼ï¼›å‰ç½®ç‰ˆæœ¬`++a`è¿”å›ç»“æœäº¦ä¸º**å·¦**å€¼
- ç®­å¤´è¿ç®—ç¬¦`p->ele`è¿”å›**å·¦**å€¼ï¼›ç‚¹è¿ç®—ç¬¦`a.ele`è¿”å›å€¼å·¦å³ç±»å‹**å’Œ`a`ç›¸åŒ**

### ğŸŒ± `sizeof`è¿ç®—ç¬¦

`sizeof`è¿ç®—ç¬¦è¿”å›ä¸€æ¡è¡¨è¾¾å¼æˆ–è€…ä¸€ä¸ªç±»å‹åå­—æ‰€å çš„å­—èŠ‚æ•°ï¼Œè¿”å›ç±»å‹ä¸º`size_t`ç±»å‹çš„**å¸¸é‡è¡¨è¾¾å¼**ã€‚   
`sizeof`è¿ç®—ç¬¦æ»¡è¶³å³ç»“åˆå¾‹ã€‚    
`sizeof`å¹¶**ä¸å®é™…è®¡ç®—å…¶è¿ç®—å¯¹è±¡çš„å€¼**ã€‚
æœ‰ä¸¤ç§å½¢å¼ï¼š
```
sizeof(Type)  // è¿”å›ç±»å‹å¤§å°
sizeof expr   // è¿”å›è¡¨è¾¾å¼ç»“æœç±»å‹å¤§å°
```
`sizeof`è¿ç®—ç¬¦çš„ç»“æœéƒ¨åˆ†åœ°ä¾èµ–äºå…¶ä½œç”¨çš„ç±»å‹
- å¯¹`char`ï¼Œæˆ–è€…`char`ç±»å‹çš„è¡¨è¾¾å¼ï¼Œæ‰§è¡Œç»“æœä¸º`1`
- å¯¹ *å¼•ç”¨* ï¼Œæ‰§è¡Œç»“æœä¸º**è¢«å¼•ç”¨å¯¹è±¡æ‰€å ç©ºé—´**çš„å¤§å°
- å¯¹ *è§£å¼•ç”¨æŒ‡é’ˆ* ï¼Œæ‰§è¡Œç»“æœä¸º**æŒ‡é’ˆæŒ‡å‘å¯¹è±¡æ‰€å ç©ºé—´**å¤§å°ï¼ŒæŒ‡é’ˆ**ä¸éœ€**æœ‰æ•ˆ
    - æ— æ•ˆæŒ‡é’ˆæ˜¯å®‰å…¨çš„ï¼Œå› ä¸º`sizeof`**ä¸è®¡ç®—å…¶è¿ç®—å¯¹è±¡çš„å€¼**
- å¯¹ *æ•°ç»„å¤´* ï¼Œæ‰§è¡Œç»“æœä¸º**æ•´ä¸ªæ•°ç»„æ‰€å ç©ºé—´**çš„å¤§å°ï¼Œç­‰ä»·äºå¯¹æ•°ç»„ä¸­æ‰€æœ‰å…ƒç´ å„è‡ªæ‰§è¡Œä¸€æ¬¡`sizeof`åå†æ±‚å’Œã€‚`sizeof`**ä¸ä¼š**æŠŠæ•°ç»„å¤´è½¬æ¢ä¸ºæŒ‡é’ˆå¤„ç†
- å¯¹`std::string`ã€`std::vector`å¯¹è±¡ï¼Œæ‰§è¡Œç»“æœä¸ºè¯¥ç±»å‹**å›ºå®šéƒ¨åˆ†**å¤§å°ï¼Œ**ä¸ä¼š**è®¡ç®—å¯¹è±¡ä¸­çš„å…ƒç´ å…·ä½“å ç”¨å¤šå¤§ç©ºé—´

### ğŸŒ± å¼ºåˆ¶ç±»å‹è½¬æ¢

#### å‘½åçš„å¼ºåˆ¶ç±»å‹è½¬æ¢

å¦‚æœ`T`æ˜¯å¼•ç”¨ç±»å‹ï¼Œåˆ™è½¬æ¢ç»“æœä¸º**å·¦**å€¼

- `static_cast<T>(expr)`
    - ç”¨äºä»»ä½•å…·æœ‰æ˜ç¡®å®šä¹‰çš„ä¸åŒ…å«åº•å±‚`const`çš„å¼ºåˆ¶ç±»å‹è½¬æ¢ã€‚ç»“æœçš„å€¼å’Œè¢«è½¬æ¢å¯¹è±¡çš„å€¼å¯èƒ½ä¸åŒã€‚ä¾‹å¦‚
        - `double`å¼ºè½¬`int`
            - å³å¼ºåˆ¶æˆªå–æ•´æ•°éƒ¨åˆ†ï¼Œæœ‰ç²¾åº¦æŸå¤±
        - `void *`å¼ºè½¬`T *`
            - å…¶å®è¿™ä¸€æ¡å…¶å®ä¹Ÿå¯ä»¥ç”¨`reinterpret_cast`ï¼Œå› ä¸º`void *`å¼ºè½¬`T *`çš„è¯­ä¹‰å°±æ˜¯å¼ºè¡ŒæŒ‰ç…§`T *`è§£é‡Šé‚£å—å†…å­˜
- `dynamic_cast<T>(expr)`
    - æ”¯æŒè¿è¡Œæ—¶çš„ç±»å‹è¯†åˆ« => 19.2
- `const_cast<T>(expr)`
    - ç”¨äºä¸”åªæœ‰å®ƒèƒ½ç”¨äºæ”¹å˜è¿ç®—å¯¹è±¡çš„**åº•å±‚**`const`ï¼ˆcast away the `const`ï¼‰
        - å³ï¼šåªèƒ½ç”¨äºæŒ‡é’ˆæˆ–å¼•ç”¨
        ```
        int b = 2;
        const int c0 = const_cast<const int>(b);                 // é”™è¯¯ï¼šconst intç±»å‹ä¸æ˜¯æŒ‡é’ˆæˆ–å¼•ç”¨
        const int & c1 = const_cast<const int &>(b);             // æ­£ç¡®
        const int & c2 = static_cast<const int &>(b);            // æ­£ç¡®
        const int & c3 = b;                                      // æ­£ç¡®
        ```
    - åªèƒ½ç”¨äºæ›´æ”¹`const`å±æ€§ï¼Œä¸èƒ½æ›´æ”¹ç±»å‹
    - å¦‚æœ`expr`æŒ‡å‘çš„å¯¹è±¡**æœ¬èº«ä¸æ˜¯å¸¸é‡**ï¼Œåˆ™é€šè¿‡`const_cast`è·å–å†™æƒé™æ˜¯åˆæ³•è¡Œä¸ºï¼›ä½†å¦‚æœå¯¹è±¡æœ¬èº«æ˜¯å¸¸é‡ï¼Œåˆ™ç»“æœ *æœªå®šä¹‰* 
    ```
    const char * pc;
    char * p = const_cast<char *>(pc);                           // æ­£ç¡®ï¼Œä½†é€šè¿‡på†™å€¼æ˜¯æœªå®šä¹‰çš„è¡Œä¸º
    char * q = static_cast<char *>(cp);                          // é”™è¯¯ï¼Œstatic_castä¸èƒ½ç”¨äºå»é™¤const
    static_cast<std::string>(pc);                                // æ­£ç¡®ï¼Œå­—ç¬¦ä¸²å­—é¢å€¼è½¬æ¢ä¸ºstd::string
    const_cast<std::string>(pc);                                 // é”™è¯¯ï¼Œconst_caståªèƒ½ç”¨äºå»é™¤const
    ```
- `reinterpret_cast<T>(expr)`
    - å¼ºåˆ¶ç¼–è¯‘å™¨æŒ‰ç…§`T`ç±»å‹é‡æ–°è§£è¯»ä¸€å—å†…å­˜
    ```
    int * a = new int(1);
    char * pc = reinterpret_cast<char *>(a);                     // æ­£ç¡®
    std::string s(pc);                                           // å¯èƒ½ä¼šREï¼Œï¼ˆå–å†³äºä»aå¼€å§‹å¤šä¹…å‡ºç°0ï¼Ÿï¼‰
    ```
    - éœ€è¦ä½¿ç”¨`reinterpret_cast`çš„åœºæ™¯ï¼ˆä¸èƒ½ç”¨`static_cast`çš„åœºæ™¯ï¼Œæš‚æ—¶æ²¡å‘ç°ç¬¬3ç§å¦™ç”¨ï¼‰
        - å°†æŒ‡é’ˆå¼ºè½¬æˆæŒ‡é’ˆ
            - ï¼ˆæ¯”å¦‚è§£æäºŒè¿›åˆ¶æ•°æ®æµï¼‰
            ```
            uint8_t dat[12] = {0};                               // å‡è®¾è¿™æ˜¯å°ç«¯æœºä¸Šçš„äºŒè¿›åˆ¶æ•°æ®æµ
            dat[0] = 1U;
            dat[4] = 2U;
            dat[8] = 3U;
            uint32_t * arr = reinterpret_cast<uint32_t *>(dat);  // æ­£ç¡®
            uint32_t * arr2 = static_cast<uint32_t *>(dat);      // é”™è¯¯ï¼šuint8_t *è½¬æ¢ä¸ºuint32_t *æ˜¯æ²¡æœ‰æ˜ç¡®å®šä¹‰çš„

            for (size_t i = 0; i < 3; ++i)
            {
                printf("%p %u\n", arr + i, arr[i]);              // è¾“å‡ºï¼š1, 2, 3
            }
            ```
            - ï¼ˆæˆ–åƒé¥±äº†æ’‘çš„å»æ¢ç©¶æ•°æ®åœ¨å†…å­˜ä¸­çš„äºŒè¿›åˆ¶å­˜å‚¨ï¼‰
            ```
            float pi = 3.14159;
            int * p1 = reinterpret_cast<int *>(&pi);     
            printf("0x%x\n", *p1);                               // 0x40490fd0
            
            uint32_t r = 0x40490fd0;   
            float * p2 = reinterpret_cast<float *>(&r);
            printf("%f\n", *p2);                                 // 3.141590
            ```
        - å°†æŒ‡é’ˆå¼ºè½¬æˆæ•°å­—ï¼ˆè·å–å…·ä½“çš„åœ°å€ï¼‰
        ```
        int a = 1, 
        int * p = &a;
        size_t b = (size_t) p;                                   // æ­£ç¡®ï¼šäººè§äººçˆ±çš„Cé£æ ¼å¼ºè½¬
        size_t b2 = static_cast<size_t>(p);                      // é”™è¯¯ï¼šint *è½¬æ¢ä¸ºsize_tæ˜¯æ²¡æœ‰æ˜ç¡®å®šä¹‰çš„
        size_t b3 = reinterpret_cast<size_t>(p);                 // æ­£ç¡®
        ```
        
#### æ—§å¼çš„å¼ºåˆ¶ç±»å‹è½¬æ¢

- ä»¥ä¸‹ä¸¤ç§è¯­æ³•ç­‰ä»·ï¼Œå› ä¸ºå…·ä½“è¡Œä¸ºéš¾ä»¥æ–­è¨€ä¸”å¯èƒ½éšå¼è¿›è¡Œ`reinterpret_cast`ï¼Œéƒ½åº”é¿å…ä½¿ç”¨
```
T t = T(expr);   // å‡½æ•°å¼
T t = (T) expr;  // Cé£æ ¼
```
- æ ¹æ®å…·ä½“ä½ç½®ä¸åŒï¼Œæ—§å¼çš„å¼ºåˆ¶ç±»å‹è½¬æ¢çš„æ•ˆæœä¸`static_cast`ã€`const_cast`æˆ–`reinterpret_cast`ç›¸åŒã€‚å…·ä½“æ¥è®²ï¼Œå®šä¹‰ä¸ºä»¥ä¸‹å„é¡¹ä¸­ç¬¬ä¸€ä¸ªæˆåŠŸçš„
    - `const_cast`
    - `static_cast` (though ignoring access restrictions)
    - `static_cast` (though ignoring access restrictions), then `const_cast`
    - `reinterpret_cast`
    - `reinterpret_cast`, then `const_cast`
```
int * ip;
char * cp = (char *) ip;  // ç›¸å½“äºreinterpret_cast<char *>(ip);
```

### ğŸŒ± `switch`

`switch`è¯­å¥ä¸­å®šä¹‰çš„å˜é‡çš„ä½œç”¨åŸŸæ˜¯**æ•´ä¸ª`switch`è¯­å¥**ï¼Œè€Œä¸ä»…æ˜¯æŸä¸ªå•ç‹¬çš„`case`ï¼

å¦‚æœæŸå¤„ä¸€ä¸ª**å¸¦æœ‰åˆå€¼**çš„å˜é‡ä½äºä½œç”¨åŸŸä¹‹å¤–ï¼Œåœ¨å¦ä¸€å¤„è¯¥å˜é‡ä½äºä½œç”¨åŸŸä¹‹å†…ï¼Œ
åˆ™ä»å‰ä¸€å¤„è·³è½¬è‡³åä¸€å¤„çš„è¡Œä¸ºæ˜¯éæ³•çš„ã€‚

```
int num = 2;

switch (num)
{
case 0:
    // å› ä¸ºç¨‹åºçš„æ‰§è¡Œæµç¨‹å¯èƒ½ç»•å¼€ä¸‹é¢çš„åˆå§‹åŒ–è¯­å¥ï¼Œæ‰€ä»¥æ­¤switchè¯­å¥ä¸åˆæ³•
    std::string filename;  // é”™è¯¯ï¼šæ§åˆ¶æµç»•è¿‡ä¸€ä¸ªéšå¼åˆå§‹åŒ–çš„å˜é‡
    int i = 0;             // é”™è¯¯ï¼šæ§åˆ¶æµç»•è¿‡ä¸€ä¸ªæ˜¾å¼åˆå§‹åŒ–çš„å˜é‡
    int j;                 // æ­£ç¡®ï¼šjæ²¡æœ‰åˆå§‹åŒ–
    j = 1;                 // æ­£ç¡®ï¼šå¯ä»¥ç»™jèµ‹å€¼ï¼Œè¿™æ ·å°±ä¸æ˜¯åˆå§‹åŒ–äº†
    break;
    
case 1:
    // æ­£ç¡®ï¼šè™½ç„¶jåœ¨ä½œç”¨åŸŸä¹‹å†…ï¼Œä½†å®ƒæ²¡æœ‰è¢«åˆå§‹åŒ–
    j = nextNum();         // æ­£ç¡®ï¼šç»™jèµ‹å€¼
    
    if (filename.empty())  // filenameåœ¨ä½œç”¨åŸŸå†…ï¼Œä½†æ²¡æœ‰è¢«åˆå§‹åŒ–
    {
        // do something...
    }
    
    break;
    
default:
    j = 2;
    std::cout <<j << std::endl;
    break;
}
```

### ğŸŒ± è°ƒè¯•å¸®åŠ©

#### `assert`

- å®šä¹‰`#define NDEBUG`å¯ä»¥å…³é—­`assert`å®æ£€æŸ¥
- ä»¥ä¸‹å®å¯ç”¨äºç»†åŒ–è°ƒè¯•ä¿¡æ¯
````
__func__
__FILE__
__LINE__
__TIME__
__DATE__
````

### ğŸŒ± [Chap 6] å‡½æ•°

#### å‡½æ•°è¿”å›å€¼

```
std::string foo(const std::string & word)
{
    return word;  // ç”Ÿæˆä¸€ä¸ªwordçš„å‰¯æœ¬ï¼ˆcopyï¼‰ï¼Œè¿”å›ä¹‹ã€‚è¿™é‡Œæœ‰ä¸€æ¬¡æ‹·è´çš„æ€§èƒ½æŸå¤± => ä½¿ç”¨å³å€¼å¼•ç”¨å¯ä»¥é¿å…
}
```

- ä¸è¦è¿”å›å±€éƒ¨å¯¹è±¡çš„å¼•ç”¨æˆ–è€…æŒ‡é’ˆ
- è°ƒç”¨ä¸€ä¸ªè¿”å›å¼•ç”¨çš„å‡½æ•°è·å¾—å·¦å€¼ï¼Œå¦åˆ™è·å¾—å³å€¼
- åˆ—è¡¨åˆå§‹åŒ–è¿”å›å€¼
    - å¦‚æœè¿”å›çš„æ˜¯å†…ç½®ç±»å‹ï¼Œåˆ™å¤§æ‹¬å·å†…åªèƒ½æœ‰1ä¸ªå€¼ï¼›å¦‚æœæ˜¯ç±»ï¼Œç”±ç±»å®šä¹‰åˆå§‹å€¼å¦‚ä½•è¢«ä½¿ç”¨
```
std::vector<std::string> process()
{
    return {"func", "success"};
}
```
- è¿”å›æ•°ç»„æŒ‡é’ˆçš„è‹¥å¹²éªšæ“ä½œ
    - æ­£å¸¸å†™
    ```
    int (*fun(int i))[10];
    ```
    - ä½¿ç”¨ *å°¾ç½®è¿”å›å€¼* 
    ```
    auto fun(int i) -> int (*)[10];
    ```
    - ä½¿ç”¨`decltype`ï¼šåœ¨å·²çŸ¥è¦è¿”å›çš„æ˜¯è°çš„æƒ…å†µä¸‹
    ```
    int odd[] = {1, 3, 5, 7, 9};
    int even[] = {0, 2, 4, 6, 8};
    
    decltype(odd) *arrPtr(int i)        // decltypeä¸è´Ÿè´£æŠŠæ•°ç»„ç±»å‹è½¬åŒ–æˆæŒ‡é’ˆã€‚å› ä¸ºä¸èƒ½è¿”å›æ•°ç»„ï¼Œæ‰€ä»¥è¦åŠ ä¸€ä¸ª*ï¼Œè¿”å›æ•°ç»„æŒ‡é’ˆ
    {
        return (i % 2) ? &odd : &even;  
    }
    ```

#### å‡½æ•°é‡è½½

- é¡¶å±‚`const`ä¸å½±å“ä¼ å…¥çš„å¯¹è±¡ï¼Œå› æ­¤ä»¥ä¸‹å®šä¹‰ä¸åˆæ³•
```
Record lookup(Phone);
Record lookup(const Phone);      // redeclares Record lookup(Phone)

Record lookup(Phone *);
Record lookup(Phone * const);    // redeclares Record lookup(Phone *)
```
- å¯ä»¥åŸºäºåº•å±‚`const`é‡è½½å‡½æ•°
```
// functions taking const and nonconst references or pointers have different parameters
// declarations for four independent, overloaded functions
Record lookup(Account &);        // function that takes a reference to Account
Record lookup(const Account &);  // new function that takes a const reference
Record lookup(Account *);        // new function, takes a pointer to Account
Record lookup(const Account *);  // new function, takes a pointer to const
```
- ç±»æˆå‘˜å‡½æ•°åŸºäº`const`çš„é‡è½½
    - é€šè¿‡åŒºåˆ†æˆå‘˜å‡½æ•°æ˜¯å¦ä¸º`const`çš„ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹å…¶è¿›è¡Œé‡è½½ï¼›
    - åŸç†ï¼šç¼–è¯‘å™¨å¯ä»¥æ ¹æ®`this`æŒ‡é’ˆå‚æ•°çš„åº•å±‚`const`åŒºåˆ†å‚æ•°ç±»å‹
- ä¸å…è®¸ä¸¤ä¸ªå‡½æ•°é™¤äº†è¿”å›å€¼å…¶ä½™éƒ½ç›¸åŒï¼š
```
Record lookup(const Account&);
bool lookup(const Account&);     // error: only the return type is different
```

#### æ•°ç»„å½¢å‚

- æ•°ç»„çš„ä¸¤ä¸ªç‰¹æ®Šæ€§è´¨
    - ä¸å…è®¸æ‹·è´æ•°ç»„
    - ä½¿ç”¨æ•°ç»„å¤´æ—¶ï¼ˆé€šå¸¸ï¼‰ä¼šå°†å…¶è½¬æ¢æˆæŒ‡å‘æ•°ç»„0å·å…ƒç´ çš„æŒ‡é’ˆ
        - åŒ…æ‹¬`auto`
        - ä¸åŒ…æ‹¬`decltype`

```
// å°½ç®¡å½¢å¼ä¸åŒï¼Œä»¥ä¸‹ä¸‰ä¸ªå‡½æ•°å£°æ˜ç­‰ä»·ï¼Œéƒ½æœ‰ä¸€ä¸ªconst int *ç±»å‹å½¢å‚
void print(const int *);    
void print(const int[]);
void print(const int[10]);  // æ­¤å¤„é•¿åº¦æ²¡æœ‰æ„ä¹‰ã€‚å¯ä»¥ä¼ å…¥é•¿åº¦ä¸ä¸º10çš„æ•°ç»„ï¼Œæ˜¯åˆæ³•çš„
```

#### å¯å˜å½¢å‚

- åˆå§‹åŒ–åˆ—è¡¨ï¼ˆ`initializer-list`ï¼‰ï¼šç”¨äºæ‰€æœ‰å®å‚ç±»å‹ç›¸åŒçš„å‡½æ•°
```
#include <initializer-list>

std::initializer-list<T> lst;              // é»˜è®¤åˆå§‹åŒ–ã€‚Tç±»å‹å…ƒç´ çš„ç©ºåˆ—è¡¨
std::initializer-list<T> lst{a, b, c...};  // lstå…ƒç´ æ•°é‡å’Œåˆå§‹å€¼ä¸€æ ·å¤šï¼›
                                           // lstçš„å…ƒç´ æ˜¯å¯¹åº”åˆå§‹å€¼çš„æ‹·è´ï¼ˆcopiesï¼‰ï¼›
                                           // åˆ—è¡¨ä¸­çš„å…ƒç´ æ°¸è¿œã€å‡ä¸ºå¸¸é‡ï¼Œä¸èƒ½æ”¹å˜

lst2(lst);                                 // æ‹·è´æˆ–èµ‹å€¼ä¸€ä¸ªåˆå§‹åŒ–åˆ—è¡¨å¯¹è±¡ä¸ä¼šæ‹·è´åˆ—è¡¨ä¸­çš„å…ƒç´ ï¼›
lst3 = lst;                                // æ‹·è´åï¼ŒåŸå§‹åˆ—è¡¨å’Œå‰¯æœ¬å…±äº«å…ƒç´ 

lst.size();                                // åˆ—è¡¨ä¸­çš„å…ƒç´ æ•°é‡
lst.begin();                               // è¿”å›æŒ‡å‘lstä¸­é¦–å…ƒç´ çš„æŒ‡é’ˆ
lst.end();                                 // è¿”å›æŒ‡å‘lstä¸­å°¾å…ƒç´ ä¸‹ä¸€ä½ç½®çš„æŒ‡é’ˆ
```

```
void error_msg(std::initializer_list<std::string> il)
{
    for (const std::string & s = il.begin(); s != il.end(); ++s)
    {
        std::cout << *s << " ";
    }
    
    std::cout << std::endl;
}

expected == actual ? error_msg({"functionX", "okay"}) : error_msg({"functionX", expected, actual});
```
- çœç•¥ç¬¦å½¢å‚ï¼šä»…ç”¨äº`C`å’Œ`C++`é€šç”¨çš„ç±»å‹ï¼Œåªèƒ½ä½œä¸ºå‡½æ•°çš„æœ€åä¸€ä¸ªå‚æ•°
```
#include <cstdarg>

// ä¸‰ç§å£°æ˜æ ¼å¼ï¼š
void foo(parm_list, ...);
void foo(parm_list...);
void foo(...);
```

```
#include <iostream>
#include <cstdarg>
#include <cmath>
 
double sample_stddev(int count, ...) 
{
    double sum = 0;
    std::va_list args1;
    va_start(args1, count);                      // ç¬¬äºŒä¸ªå‚æ•°æ˜¯va_listå‰é¢çš„å…·åå‚æ•°çš„åå­—
    std::va_list args2;
    va_copy(args2, args1);
    
    for (int i = 0; i < count; ++i) 
    {
        double num = va_arg(args1, double);
        sum += num;
    }
    
    va_end(args1);                               // è°ƒç”¨va_startä¹‹åä¸è°ƒç”¨va_endï¼Œè¡Œä¸ºæœªå®šä¹‰
    double mean = sum / count;
 
    double sum_sq_diff = 0;
    
    for (int i = 0; i < count; ++i) 
    {
        double num = va_arg(args2, double);
        sum_sq_diff += (num-mean) * (num-mean);  
    }
    
    va_end(args2);                               // è°ƒç”¨va_copyä¹‹åä¸è°ƒç”¨va_endï¼Œè¡Œä¸ºæœªå®šä¹‰
    return std::sqrt(sum_sq_diff / count);
}
 
std::cout << sample_stddev(4, 25.0, 27.3, 26.9, 25.7) << std::endl;
```
- å¯å˜å‚æ•°æ¨¡æ¿ => 16.4

#### å‡½æ•°æŒ‡é’ˆ

- å£°æ˜ï¼šç”¨æŒ‡é’ˆæ›¿ä»£å‡½æ•°åå³å¯
    - `bool lengthCompare(const std::string &, const stf::string)`çš„ç±»å‹æ˜¯`bool(const std::string &, const stf::string)`
    - å£°æ˜æŒ‡å‘`bool(const std::string &, const stf::string)`ç±»å‹å‡½æ•°çš„æŒ‡é’ˆ
        - `bool (*pf)(const std::string &, const stf::string);      // æœªåˆå§‹åŒ–`
- ä½¿ç”¨

```
pf = lengthCompare;                                                 // pf now points to lengthCompare()
pf = &lengthCompare;                                                // equivalent assignment: & is optional

bool b1 = pf("hello", "goodbye");                                   // calls lengthCompare
bool b2 = (*pf)("hello", "goodbye");                                // equivalent call
bool b3 = lengthCompare("hello", "goodbye");                        // equivalent call
```
- é‡è½½å‡½æ•°çš„æŒ‡é’ˆï¼šå‡½æ•°æŒ‡é’ˆçš„ç±»å‹å¿…é¡»ä¸é‡è½½å‡½æ•°ä¸­çš„æŸä¸€ä¸ªç²¾ç¡®åŒ¹é…
```
void ff(int*);
void ff(unsigned int);
void (*pf1)(unsigned int) = 0;                                      // pf1 points to nothing
void (*pf2)(unsigned int) = ff;                                     // pf1 points to ff(unsigned int)

void (*pf3)(int) = ff;                                              // error: no ff with a matching parameter list
double (*pf4)(int*) = ff;                                           // error: return type of ff and pf4 don't match
```
- ä½¿ç”¨ç±»å‹åˆ«åï¼ˆ`typedef`æˆ–`using`ï¼‰å¯ä»¥ç®€åŒ–ä¹¦å†™
```
typedef bool Func(const std::string &, const std::string &);        // function type
typedef decltype(lengthCompare) Func2;                              // equivalent type

typedef bool (*FuncP)(const std::string &, const std::string &);    // function pointer type
typedef decltype(lengthCompare) * FuncP2;                           // equivalent type
using FuncP3 = bool (*)(const std::string &, const std::string &);  // equivalent type
using FuncP4 = decltype(lengthCompare) *;                           // equivalent type
```
- ä¸æ•°ç»„æŒ‡é’ˆçš„è¾¨æ
    - æ³¨æ„
        - å‡½æ•°åä¼šè½¬åŒ–æˆå‡½æ•°æŒ‡é’ˆ
        - æ•°ç»„å¤´ä¼šè½¬åŒ–æˆæŒ‡å‘æ•°ç»„å…ƒç´ ç±»å‹çš„æŒ‡é’ˆï¼Œè€Œä¸æ˜¯æŒ‡å‘æ•°ç»„ç±»å‹çš„æŒ‡é’ˆ
        ```
        bool le(int, int);
        bool (*pf1)(int, int) = le;               // æ­£ç¡®
        bool (*pf2)(int, int) = &le;              // æ­£ç¡®
        
        int arr[10];
        int * p1 = arr;                           // æ­£ç¡®
        int * p2 = &arr;                          // é”™è¯¯
        int *(p3)[10] = &arr;                     // æ­£ç¡®
        ```
    - æ•°ç»„æŒ‡é’ˆçš„ç±»å‹åˆ«å
    ```
    int arr[10];

    typedef int (*int_arr_10_ptr_t1)[10];         // æŒ‡å‘é•¿åº¦ä¸º10çš„intæ•°ç»„çš„æŒ‡é’ˆç±»å‹çš„åˆ«å
    typedef decltype(arr) * int_arr_10_ptr_t2;    // ç­‰ä»·ç±»å‹åˆ«å

    using int_arr_10_ptr_t3 = int[10];            // ç­‰ä»·ç±»å‹åˆ«å
    using int_arr_10_ptr_t4 = decltype(arr) *;    // ç­‰ä»·ç±»å‹åˆ«å
    ```

#### å‡½æ•°æŒ‡é’ˆå½¢å‚

- å£°æ˜
```
// third parameter is a function type and is automatically treated as a pointer to function
void 
useBigger(const string & s1, 
          const string & s2,
          bool pf(const string &, const string &));
          
// equivalent declaration: explicitly define the parameter as a pointer to function
void 
useBigger(const string & s1, 
          const string & s2,
          bool (*pf)(const string &, const string &));
```
- ä½¿ç”¨ï¼šä¼ å…¥å‡½æ•°åã€å‡½æ•°åæ‰‹åŠ¨å–åœ°å€æˆ–è€…å·²æœ‰çš„æŒ‡é’ˆå‡å¯
```          
// automatically converts the function lengthCompare to a pointer to function
useBigger(s1, s2, lengthCompare);
useBigger(s1, s2, &lengthCompare);
useBigger(s1, s2, pf);
```

### ğŸŒ± [Chap 8] `I/O`åº“

- è¿™ç« æŒºæ²¡æ„æ€çš„ï¼Œå…¨ç¯‡åœ¨è®²`<iostream>`ï¼Œè¿˜æ˜¯`C`é£æ ¼`I/O`ç”¨ç€èˆ’æœ

### ğŸŒ± [Chap 7] ç±»ï¼ˆåŸºç¡€æ¦‚å¿µï¼‰

#### åˆæˆçš„é»˜è®¤æ„é€ å‡½æ•°ï¼ˆsynthesized default constructorï¼‰

- æŒ‰å¦‚ä¸‹è§„åˆ™åˆå§‹åŒ–ç±»æˆå‘˜
    - å­˜åœ¨ç±»å†…åˆå§‹å€¼ï¼Œåˆ™ä»¥å…¶åˆå§‹åŒ–å¯¹åº”æˆå‘˜
        - ç±»å†…åˆå§‹å€¼å¯æ¥å—çš„è¯­æ³•
        ```
        int a1 = 0;    // æ­£ç¡®
        int a2 = {0};  // æ­£ç¡®
        int a3{0};     // æ­£ç¡®
        int a4(0);     // é”™è¯¯ï¼
        ```
    - *é»˜è®¤åˆå§‹åŒ–* æˆ– *å€¼åˆå§‹åŒ–* è¯¥æˆå‘˜
        - [*é»˜è®¤åˆå§‹åŒ–*](https://en.cppreference.com/w/cpp/language/default_initialization)
            ```
            T object;                             (1)
            new T                                 (2)
            ```
            1. if `T` is an `array type`, every element of the array is *default-initialized* ;
            2. otherwise, nothing is done: the objects with automatic storage duration (and their subobjects) are initialized to *indeterminate values* . 
        - [*å€¼åˆå§‹åŒ–*](https://en.cppreference.com/w/cpp/language/value_initialization)
            ```
            T()                                   (1)
            new T ()                              (2)
            Class::Class(...) : member() { ... }  (3)
            T object {};                          (4)
            T{}                                   (5)
            new T {}                              (6)
            Class::Class(...) : member{} { ... }  (7)
            ```
            1. if `T` is a `class type` with no default constructor or with a user-provided or deleted default constructor, the object is *default-initialized* ;
            2. if `T` is a `class type` with a default constructor that is neither user-provided nor deleted (that is, it may be a class with an implicitly-defined or defaulted default constructor), the object is *zero-initialized* and then it is *default-initialized* if it has a non-trivial default constructor;
            3. if `T` is an `array type`, each element of the array is *value-initialized*;
            4. otherwise, the object is *zero-initialized* .
- ç”Ÿæˆæ¡ä»¶ï¼š
    - åªæœ‰ç±»**æ²¡æœ‰å£°æ˜ä»»ä½•æ„é€ å‡½æ•°**æ—¶ï¼Œç¼–è¯‘å™¨æ‰ä¼šè‡ªåŠ¨ç”Ÿæˆé»˜è®¤æ„é€ å‡½æ•°
    - å¦‚æœç±»ä¸­åŒ…å«å…¶ä»–ç±»ç±»å‹æˆå‘˜ï¼Œä¸”å®ƒæ²¡æœ‰é»˜è®¤æ„é€ å‡½æ•°ï¼Œåˆ™è¿™ä¸ªç±»**ä¸èƒ½**ç”Ÿæˆé»˜è®¤æ„é€ å‡½æ•°
    - => 13.1.6
- å¦‚æœç±»å†…åŒ…å«å†…ç½®ç±»å‹æˆ–å¤åˆç±»å‹çš„å˜é‡ï¼Œåˆ™åªæœ‰å½“è¿™äº›æˆå‘˜å…¨éƒ¨è¢«èµ‹äºˆäº†ç±»å†…åˆå§‹å€¼æ—¶ï¼Œè¿™ä¸ªç±»æ‰é€‚åˆäºä½¿ç”¨é»˜è®¤æ„é€ å‡½æ•°
    - æ³¨æ„ï¼šç±»æˆå‘˜å˜é‡ä»å±äºå†…éƒ¨ä½œç”¨åŸŸï¼Œé»˜è®¤åˆå§‹åŒ–æ˜¯ *æœªå®šä¹‰* çš„ï¼Œä¸èƒ½æŒ‡æœ›ï¼
- ç±»å¿…é¡»åŒ…å«é»˜è®¤æ„é€ å‡½æ•°ä»¥ä¾¿åœ¨ä¸Šè¿°æƒ…å†µä¸‹ä½¿ç”¨ã€‚å®é™…åº”ç”¨ä¸­ï¼Œå¦‚æœæä¾›äº†å…¶å®ƒæ„é€ å‡½æ•°ï¼Œæœ€å¥½ä¹Ÿæä¾›ä¸€ä¸ªé»˜è®¤æ„é€ å‡½æ•°
    - `= default;`
        - ç”¨äºæ—¢å®šä¹‰äº†è‡ªå·±çš„æ„é€ å‡½æ•°ï¼Œåˆéœ€è¦é»˜è®¤æ„é€ å‡½æ•°çš„æƒ…å†µ
        - ä½œä¸ºå£°æ˜å†™åœ¨ç±»å†…éƒ¨ï¼Œåˆ™æ„é€ å‡½æ•°é»˜è®¤`inline`ï¼›æˆ–ä½œä¸ºå®šä¹‰å†™åœ¨ç±»å¤–éƒ¨ï¼Œåˆ™æ„é€ å‡½æ•°ä¸`inline`

#### æ„é€ å‡½æ•°åˆå§‹å€¼åˆ—è¡¨

- æŸä¸ªæ•°æ®æˆå‘˜è¢«åˆå§‹å€¼åˆ—è¡¨å¿½ç•¥æ—¶ï¼Œåˆ™**å…ˆè¢«é»˜è®¤åˆå§‹åŒ–**ï¼Œä¹‹åå†æŒ‰ç…§æ„é€ å‡½æ•°ä½“ä¸­çš„è§„åˆ™è¿›è¡Œ**äºŒæ¬¡èµ‹å€¼**
- åˆå§‹åŒ–åˆ—è¡¨æ¥å—çš„åˆå§‹åŒ–è¯­æ³•ï¼š`x(?)`æˆ–`x{?}`
- å¦‚æœæˆå‘˜æ˜¯`const`ã€å¼•ç”¨æˆ–è€…æ²¡æœ‰é»˜è®¤æ„é€ å‡½æ•°çš„ç±»ç±»å‹ï¼Œå¦‚æ²¡æœ‰ç±»å†…åˆå§‹å€¼ï¼Œåˆ™**å¿…é¡»**åœ¨åˆå§‹åŒ–åˆ—è¡¨ä¸­åˆå§‹åŒ–ï¼Œè€Œä¸èƒ½åœ¨å‡½æ•°ä½“ä¸­èµ‹å€¼
- åˆå§‹åŒ–çš„é¡ºåºæ˜¯æŒ‰ç…§ç±»æˆå‘˜è¢«å£°æ˜çš„é¡ºåºï¼Œä¸å…¶åœ¨åˆ—è¡¨ä¸­çš„é¡ºåºæ— å…³
    - æœ€å¥½ä»¤æ„é€ å‡½æ•°åˆå§‹åŒ–åˆ—è¡¨çš„é¡ºåºä¸æˆå‘˜å£°æ˜çš„é¡ºåºä¿æŒä¸€è‡´
    - å°½é‡é¿å…ç”¨æŸäº›æˆå‘˜åˆå§‹åŒ–å…¶ä»–æˆå‘˜ï¼Œæœ€å¥½ç”¨æ„é€ å‡½æ•°çš„å‚æ•°ä½œä¸ºåˆå§‹å€¼
- å¦‚æœä¸€ä¸ªæ„é€ å‡½æ•°ä¸ºæ¯ä¸€ä¸ªå‚æ•°éƒ½æä¾›äº†é»˜è®¤å®å‚ï¼Œåˆ™å®ƒå®é™…ä¸Šä¹Ÿå®šä¹‰äº†é»˜è®¤æ„é€ å‡½æ•°

#### å§”æ‰˜æ„é€ å‡½æ•°ï¼ˆdelegating constructorï¼‰

- ä¸€ä¸ªå§”æ‰˜æ„é€ å‡½æ•°ä½¿ç”¨å®ƒæ‰€å±ç±»çš„å…¶å®ƒæ„é€ å‡½æ•°æ‰§è¡Œå®ƒè‡ªå·±çš„åˆå§‹åŒ–è¿‡ç¨‹ï¼Œ
  æˆ–è€…è¯´å®ƒæŠŠè‡ªå·±çš„ä¸€äº›ï¼ˆæˆ–å…¨éƒ¨ï¼‰èŒè´£å§”æ‰˜ç»™äº†å…¶ä»–æ„é€ å‡½æ•°
```
struct Item
{
    Item() : Item(0, "")  {}  // delegating constructor
    Item(const int & k, const std::string & v) : key(k), value(v)  {}

    int key;
    std::string value;
}
```

#### è½¬æ¢æ„é€ å‡½æ•°ï¼ˆconverting constructorï¼‰

- å¦‚æœæ„é€ å‡½æ•°åªæ¥å—ä¸€ä¸ªå®å‚ï¼Œé‚£ä¹ˆå®ƒå®é™…ä¸Šå®šä¹‰äº†è½¬æ¢ä¸ºæ­¤ç±»ç±»å‹çš„ *éšå¼è½¬æ¢* æœºåˆ¶ï¼Œæœ‰æ—¶æˆ‘ä»¬å°†è¿™ç§æ„é€ å‡½æ•°ç§°ä½œ *è½¬æ¢æ„é€ å‡½æ•°* => 14.9
- èƒ½é€šè¿‡ä¸€ä¸ªå®å‚è°ƒç”¨çš„æ„é€ å‡½æ•°å®šä¹‰äº†ä¸€æ¡ä»æ„é€ å‡½æ•°çš„å‚æ•°ç±»å‹å‘ç±»ç±»å‹éšå¼è½¬æ¢çš„è§„åˆ™
- ç¼–è¯‘å™¨**åªå…è®¸ä¸€æ­¥**éšå¼ç±»å‹è½¬æ¢ï¼Œä¸”è½¬æ¢ç»“æœæ˜¯**ä¸´æ—¶å³å€¼**å¯¹è±¡
```
// é”™è¯¯ï¼šéœ€è¦ç”¨æˆ·å®šä¹‰çš„ä¸¤ç§è½¬æ¢ï¼š
// (1) æŠŠ"9-999-99999-9"è½¬æ¢æˆstd::string
// (2) å†æŠŠè¿™ä¸ªï¼ˆä¸´æ—¶çš„ï¼‰std::stringè½¬æ¢æˆSalesData
item.combine("9-999-99999-9");

// æ­£ç¡®ï¼šæ˜¾å¼åœ°è½¬æ¢æˆstd::stringï¼Œå†éšå¼åœ°è½¬æ¢æˆSalesData
item.combine(std::string("9-999-99999-9")); 

// æ­£ç¡®ï¼šéšå¼åœ°è½¬æ¢æˆstd::stringï¼Œå†æ˜¾å¼åœ°è½¬æ¢æˆSalesData
item.combine(SalesData("9-999-99999-9")); 
```

#### æ˜¾å¼æ„é€ å‡½æ•°ï¼ˆ`explicit` constructorï¼‰

- æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†æ„é€ å‡½æ•°å£°æ˜ä¸º`explicit`æ¥æŠ‘åˆ¶æ„é€ å‡½æ•°å®šä¹‰çš„éšå¼è½¬æ¢
```
class SalesData 
{
public:
    SalesData() = default;
    SalesData(const std::string & s, unsigned n, double p) : 
        bookNo(s), units_sold(n), revenue(p * n)  {}
    explicit SalesData(const std::string & s): bookNo(s)  {}
    explicit SalesData(std::istream &);
};

// æ­¤æ—¶ï¼Œæ²¡æœ‰ä»»ä½•æ„é€ å‡½æ•°èƒ½ç”¨äºéšå¼åœ°åˆ›å»º`SalesData`å¯¹è±¡ã€‚
item.combine(nullBook);                                  // é”™è¯¯ï¼Œå¯¹åº”æ„é€ å‡½æ•°æ˜¯explicitçš„
item.combine(std::cin);                                  // é”™è¯¯ï¼Œå¯¹åº”æ„é€ å‡½æ•°æ˜¯explicitçš„
```
- `explicit`**åªèƒ½åœ¨ç±»å†…å£°æ˜**ï¼Œåªå¯¹ä¸€ä¸ªå®å‚çš„æ„é€ å‡½æ•°æœ‰æ„ä¹‰
- `explicit`æ„é€ å‡½æ•°**åªèƒ½ç”¨äºç›´æ¥åˆå§‹åŒ–**
    - æ‰§è¡Œæ‹·è´å½¢å¼çš„åˆå§‹åŒ–ï¼ˆä½¿ç”¨`=`ï¼‰æ—¶ï¼Œå®é™…å‘ç”Ÿäº†éšå¼ç±»å‹è½¬æ¢ã€‚æ­¤æ—¶åªèƒ½ç›´æ¥åˆå§‹åŒ–ï¼Œè€Œä¸èƒ½ä½¿ç”¨`explicit`æ„é€ å‡½æ•°
    ```
    SalesData item1(nullBook);                           // æ­£ç¡®
    SalesData item2 = nullBook;                          // é”™è¯¯
    ```
    - ä¸ºè½¬æ¢æ˜¾å¼åœ°ä½¿ç”¨æ„é€ å‡½æ•°
    ```
    SalesData item2 = SalesData(nullBook);               // æ­£ç¡®ï¼šæ˜¾å¼æ„é€ çš„å¯¹è±¡
    SalesData item3 = static_cast<SalesData>(std::cin);  // æ­£ç¡®ï¼šstatic_castå¯ä»¥ä½¿ç”¨explicitæ„é€ å‡½æ•°
    ```
- æ ‡å‡†åº“ä¸­å«æœ‰æ˜¾å¼æ„é€ å‡½æ•°çš„ç±»
    - æ¥å—ä¸€ä¸ªå•å‚æ•°`const char *`çš„`std::string`æ„é€ å‡½æ•° *ä¸æ˜¯* `explicit`çš„
    - æ¥å—å®¹é‡å‚æ•°çš„`std::vector`æ„é€ å‡½æ•°**æ˜¯**`explicit`çš„

#### å…¶ä»–æ„é€ å‡½æ•°

- => 13
- => 15.7
- => 18.1.3

#### å‹å…ƒ

- å‹å…ƒä¸æ˜¯ç±»çš„æˆå‘˜ï¼Œä¸å—`public`ã€`private`ä»¥åŠ`protected`è¿™äº›è®¿é—®é™åˆ¶çš„çº¦æŸ
- å‹å…ƒ**ä¸å…·æœ‰**ä¼ é€’æ€§ã€‚æ¯ä¸ªç±»**å•ç‹¬**è´Ÿè´£æ§åˆ¶è‡ªå·±çš„å‹å…ƒç±»æˆ–å‹å…ƒå‡½æ•°
    - `B`æœ‰å‹å…ƒ`A`ï¼Œ`C`æœ‰å‹å…ƒ`B`ï¼Œåˆ™`A`èƒ½è®¿é—®`B`çš„ç§æœ‰æˆå‘˜ï¼Œä½†ä¸èƒ½è®¿é—®`C`çš„ç§æœ‰æˆå‘˜
- åœ¨ç±»å®šä¹‰å¼€å§‹æˆ–ç»“æŸçš„åœ°æ–¹**é›†ä¸­å£°æ˜**å‹å…ƒ
- *å‹å…ƒå‡½æ•°*
    - å‹å…ƒå‡½æ•°çš„å£°æ˜ä»…ä»…æ˜¯æŒ‡å®šè®¿é—®æƒé™ï¼Œå¹¶ä¸æ˜¯çœŸæ­£çš„å‡½æ•°å£°æ˜ã€‚æƒ³è¦ä½¿ç”¨å‹å…ƒï¼Œä»**å¦éœ€ä¸€å•ç‹¬çš„å‡½æ•°å£°æ˜**
    - å¯¹äºé‡è½½å‡½æ•°ï¼Œå¿…é¡»å¯¹ç‰¹å®šçš„å‡½æ•°ï¼ˆç‰¹æœ‰çš„å‚æ•°åˆ—è¡¨ï¼‰å•ç‹¬å£°æ˜
- *å‹å…ƒç±»*
    - ä»¤ä¸€ä¸ªç±»æˆä¸ºå‹å…ƒ
- *å‹å…ƒæˆå‘˜å‡½æ•°*
    - ä»¤ä¸€ä¸ªç±»çš„æŸä¸ªæˆå‘˜å‡½æ•°æˆä¸ºå‹å…ƒ
- *å‹å…ƒå£°æ˜å’Œä½œç”¨åŸŸ*
    - å…³äºè¿™æ®µä»£ç æœ€é‡è¦çš„æ˜¯ï¼šç†è§£å‹å…ƒå£°æ˜çš„ä½œç”¨æ˜¯**å½±å“è®¿é—®æƒé™**ï¼Œå®ƒæœ¬èº«**å¹¶é**æ™®é€šæ„ä¹‰ä¸Šçš„å‡½æ•°å£°æ˜
    - å¹¶ä¸æ˜¯æ‰€æœ‰ç¼–è¯‘å™¨éƒ½å¼ºåˆ¶æ‰§è¡Œå…³äºå‹å…ƒçš„è¿™ä¸€è§„å®š
    ```
    struct X
    {
        friend void f()
        { 
            // friend functions can be defined in the class
            // this does NOT serve as declaration, even though this is already a defination
            // to use this function, another declaration is REQUIRED
        }

        X()
        {
            f();     // ERROR: no declaration for f
        } 
        
        void g();
        void h();
    };

    void X::g()
    {
        return f();  // ERROR: f hasn't been declared
    } 

    void f();        // declares the function defined inside X

    void X::h()
    {
        return f();  // OK: declaration for f is now in scope
    } 
    ```

#### ç±»çš„ç±»å‹æˆå‘˜

- ç±»ä¸­çš„`typedef`å’Œ`using`å¿…é¡»å…ˆå®šä¹‰åä½¿ç”¨
- ä¸€èˆ¬æ”¾åœ¨ç±»å®šä¹‰åˆšå¼€å§‹çš„åœ°æ–¹çš„`public`åŒºåŸŸ

#### å¯å˜æ•°æ®æˆå‘˜ï¼ˆmutable data memberï¼‰

- å¯ç”¨äºæ›´æ”¹`const`å¯¹è±¡çš„æˆå‘˜
    - `const`å¯¹è±¡åªèƒ½è°ƒç”¨`const`æˆå‘˜å‡½æ•°
    - å¯å˜æ•°æ®æˆå‘˜æ°¸è¿œä¸ä¼šæ˜¯`const`ï¼Œå³ä½¿å®ƒæ˜¯`const`å¯¹è±¡çš„æˆå‘˜
    - ä»»ä½•æˆå‘˜å‡½æ•°ï¼ŒåŒ…æ‹¬`const`æˆå‘˜å‡½æ•°ï¼Œéƒ½å¯ä»¥æ”¹å˜å¯å˜æ•°æ®æˆå‘˜
```
class Screen 
{
public:
    inline const size_t & some_member() const;
    
private:
    mutable size_t access_ctr = 0;                 // may change even in a const object
};

inline const size_t & Screen::some_member() const
{
    return ++access_ctr;                           // keep a count of the calls to any member function
}

const Screen s1;
printf("%zu\n", s1.some_member());                 // 1
```

#### ç±»çš„å‰å‘å£°æ˜

- åªå£°æ˜ä¸å®šä¹‰ä¸€ä¸ªç±»ï¼š`class Item;`
    - åœ¨å®šä¹‰ä¹‹å‰ï¼Œ`Item`æ˜¯ *ä¸å®Œå…¨ç±»å‹*
    - ä¸å®Œå…¨ç±»å‹ä½¿ç”¨å—é™
        - å¯ä»¥å®šä¹‰æŒ‡å‘è¿™ç§ç±»å‹çš„æŒ‡é’ˆæˆ–å¼•ç”¨
        - å¯ä»¥å£°æ˜ï¼ˆ**ä¸èƒ½**å®šä¹‰ï¼‰ä»¥è¿™ç§ç±»å‹ä¸ºå‚æ•°ï¼Œæˆ–è¿”å›å€¼ç±»å‹çš„å‡½æ•°
        - **ä¸èƒ½**åˆ›å»ºè¿™ç§ç±»å‹çš„å¯¹è±¡
        - **ä¸èƒ½**ç”¨å¼•ç”¨æˆ–æŒ‡é’ˆè®¿é—®å…¶æˆå‘˜
        - *éé™æ€æ•°æ®æˆå‘˜* **ä¸èƒ½**è¢«å£°æ˜ä¸ºè¿™ç§ç±»å‹
            - *é™æ€æ•°æ®æˆå‘˜* å¯ä»¥ï¼
- ç‰¹åˆ«åœ°ï¼šç±»å¯ä»¥åŒ…å«æŒ‡å‘ *è‡ªèº«ç±»å‹* çš„å¼•ç”¨æˆ–æŒ‡é’ˆ


#### ç±»ä½œç”¨åŸŸ

```
// note: this code is for illustration purposes only and reflects bad practice
// it is generally a bad idea to use the same name for a parameter and a member
size_t shit = 2;

struct Item
{
    void print1(size_t shit) const
    {
        // shit:       function parameter
        // this->shit: class member
        // ::shit:     global one
        printf("%zu %zu %zu\n", shit, this->shit, ::shit);
    }

    size_t shit = 1;
};

Item t;
t.print1(0);  // 0 1 2
```

#### èšåˆç±»ï¼ˆaggregate classï¼‰

- *èšåˆç±»* ä½¿å¾—ç”¨æˆ·å¯ä»¥ç›´æ¥è®¿é—®å…¶æˆå‘˜ï¼Œå¹¶ä¸”å…·æœ‰ç‰¹æ®Šçš„åˆå§‹åŒ–è¯­æ³•å½¢å¼
- å½“ä¸€ä¸ªç±»æ»¡è¶³å¦‚ä¸‹æ¡ä»¶ï¼ˆæ¯”å¦‚çº¯`C`é£æ ¼çš„`struct`ï¼‰æ—¶ï¼Œæˆ‘ä»¬è¯´å®ƒæ˜¯ *èšåˆçš„*
    - æ‰€æœ‰æˆå‘˜éƒ½æ˜¯`public`çš„
    - **æ²¡æœ‰**å®šä¹‰ä»»ä½•æ„é€ å‡½æ•°
    - **æ²¡æœ‰**ç±»å†…åˆå§‹å€¼
    - **æ²¡æœ‰**åŸºç±»ï¼Œä¹Ÿæ²¡æœ‰`virtual`å‡½æ•°
- æˆ‘ä»¬å¯ä»¥æä¾›ä¸€ä¸ªèŠ±æ‹¬å·æ‹¬èµ·æ¥çš„æˆå‘˜åˆå§‹å€¼åˆ—è¡¨ï¼Œå¹¶ç”¨å®ƒåˆå§‹åŒ–èšåˆç±»çš„æˆå‘˜
```
Entry e = {0, "Anna"};
```
- ä¸åˆå§‹åŒ–æ•°ç»„å…ƒç´ çš„è§„åˆ™ä¸€æ ·ï¼Œå¦‚æœåˆå§‹å€¼åˆ—è¡¨ä¸­çš„å…ƒç´ ä¸ªæ•°å°‘äºç±»çš„æˆå‘˜æ•°é‡ï¼Œåˆ™é åçš„æˆå‘˜è¢« *å€¼åˆå§‹åŒ–*
- åˆå§‹åŒ–åˆ—è¡¨çš„å…ƒç´ ä¸ªæ•°ä¸èƒ½è¶…è¿‡ç±»çš„æˆå‘˜æ•°é‡
- æ˜¾ç¤ºåˆå§‹åŒ–ç±»çš„å¯¹è±¡æˆå‘˜å­˜åœ¨ *ä¸‰ä¸ª* æ˜æ˜¾çš„ç¼ºç‚¹
    - è¦æ±‚ç±»çš„æ‰€æœ‰æˆå‘˜éƒ½æ˜¯`public`çš„ï¼›
    - å°†æ­£ç¡®åˆå§‹åŒ–æ¯ä¸ªå¯¹è±¡çš„æ¯ä¸ªæˆå‘˜çš„è´£ä»»äº¤ç»™äº†ç”¨æˆ·ï¼Œå®¹æ˜“å‡ºé”™
    - æ·»åŠ æˆ–åˆ é™¤ä¸€ä¸ªæˆå‘˜ä¹‹åï¼Œæ‰€æœ‰çš„åˆå§‹åŒ–è¯­å¥éƒ½éœ€è¦æ›´æ–°

#### å­—é¢å€¼å¸¸é‡ç±»

- å¸¸é‡è¡¨è¾¾å¼ï¼ˆconst expressionï¼‰
    - å­—é¢å€¼
        - ç®—æ•°ç±»å‹
        - å¼•ç”¨å’ŒæŒ‡é’ˆ
        - å­—é¢å€¼å¸¸é‡ç±»
        - 19.3
    - å¸¸é‡è¡¨è¾¾å¼ï¼šå€¼**ä¸ä¼šæ”¹å˜**ã€å¹¶ä¸”åœ¨**ç¼–è¯‘è¿‡ç¨‹ä¸­å°±èƒ½å¾—åˆ°**è®¡ç®—ç»“æœçš„è¡¨è¾¾å¼
        - å­—é¢å€¼å’Œç”¨å¸¸é‡è¡¨è¾¾å¼åˆå§‹åŒ–çš„`const`å¯¹è±¡ä¹Ÿæ˜¯å¸¸é‡è¡¨è¾¾å¼
- `constexpr`å˜é‡
    - å…è®¸å°†å˜é‡å£°æ˜ä¸º`constexpr`ç±»å‹ï¼Œä»¥ä¾¿ç”±ç¼–è¯‘å™¨æ¥éªŒè¯å˜é‡çš„å€¼æ˜¯å¦æ˜¯ä¸€ä¸ªå¸¸é‡è¡¨è¾¾å¼
    - å£°æ˜ä¸º`constexpr`çš„å˜é‡ä¸€å®šæ˜¯ä¸€ä¸ªå¸¸é‡ï¼Œè€Œä¸”å¿…é¡»ç”¨å¸¸é‡è¡¨è¾¾å¼æ¥åˆå§‹åŒ–
    ```
    constexpr int mf = 20;         // æ­£ç¡®
    constexpr int limit = mf + 1;  // æ­£ç¡®
    constexpr int sz = size();     // å½“ä¸”ä»…å½“sizeæ˜¯constexprå‡½æ•°æ—¶ï¼Œæ‰æ­£ç¡®
    ```              
    - å°½ç®¡ä¸èƒ½ä½¿ç”¨æ™®é€šå‡½æ•°ä½œä¸º`constexpr`å˜é‡çš„åˆå§‹å€¼ï¼Œä½†å¯ä»¥ä½¿ç”¨`constexpr`å‡½æ•°
    - `constexpr`å¼•ç”¨å’ŒæŒ‡é’ˆ
        - åªèƒ½ç»‘å®šåˆ°å›ºå®šåœ°å€çš„å˜é‡ä¸Šï¼ˆä¾‹å¦‚ *å…¨å±€å¯¹è±¡* ï¼Œ *å±€éƒ¨é™æ€å¯¹è±¡* ï¼‰
        - **ä¸èƒ½**æŒ‡å‘å±€éƒ¨éé™æ€å¯¹è±¡
        - `constexpr`æŒ‡é’ˆå’Œå˜é‡çš„åˆå§‹å€¼å¿…é¡»æ˜¯`nullptr`ã€`0`æˆ–è€…å­˜å‚¨äºæŸä¸ªå›ºå®šåœ°å€çš„å¯¹è±¡
        - `constexpr`æŒ‡é’ˆä¸º**é¡¶å±‚**`const`
- `constexpr`å‡½æ•°
    - `constexpr`å‡½æ•°æ˜¯æŒ‡èƒ½ç”¨äºå¸¸é‡è¡¨è¾¾å¼çš„å‡½æ•°
    - å®šä¹‰`constexpr`å‡½æ•°éœ€è¦éµå®ˆ
        - å‡½æ•°çš„è¿”å›ç±»å‹å’Œæ‰€æœ‰å½¢å‚çš„ç±»å‹éƒ½æ˜¯å­—é¢å€¼ç±»å‹
        - å‡½æ•°ä½“ä¸­åªåŒ…å«è¿è¡Œæ—¶**ä¸æ‰§è¡Œä»»ä½•æ“ä½œ**çš„è¯­å¥ï¼Œä¾‹å¦‚
            - ç©ºè¯­å¥
            - ç±»å‹åˆ«å
            - `using`å£°æ˜
        - å‡½æ•°ä½“ä¸­å¦‚æœ‰å¯æ‰§è¡Œè¯­å¥ï¼Œåªèƒ½æ˜¯**ä¸€æ¡**`return`è¯­å¥
    ```
    constexpr int new_sz()  { return 42; }
    constexpr int foo = new_sz();           // æ­£ç¡®ï¼šfooæ˜¯å¸¸é‡è¡¨è¾¾å¼

    // å¦‚æœargæ˜¯å¸¸é‡è¡¨è¾¾å¼ï¼Œé‚£ä¹ˆscale(arg)ä¹Ÿæ˜¯å¸¸é‡è¡¨è¾¾å¼
    constexpr size_t scale(size_t cnt)  { return new_sz() * cnt; }

    int arr[scale(2)];                      // æ­£ç¡®
    int i = 2;                              // iä¸æ˜¯å¸¸é‡è¡¨è¾¾å¼
    int a2[scale(i)];                       // é”™è¯¯ï¼šiä¸æ˜¯å¸¸é‡è¡¨è¾¾å¼ï¼Œscale(i)ä¹Ÿä¸æ˜¯
    ```
    - æ‰§è¡Œåˆå§‹åŒ–æ—¶ï¼Œç¼–è¯‘å™¨æŠŠå¯¹`constexpr`å‡½æ•°çš„è°ƒç”¨æ›¿æ¢æˆå…¶ç»“æœå€¼
    - `constexpr`å‡½æ•°æ˜¯éšå¼çš„`inline`å‡½æ•°ï¼›
    - `constexpr`å‡½æ•°ã€`inline`å‡½æ•°ä»¥åŠæ¨¡æ¿çš„**å®šä¹‰å’Œå®ç°éƒ½åº”**å†™è¿›å¤´æ–‡ä»¶
- å­—é¢å€¼å¸¸é‡ç±»
    - `constexpr`å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼éƒ½å¿…é¡»æ˜¯å­—é¢å€¼ç±»å‹
      é™¤äº†ç®—æ•°ç±»å‹ã€å¼•ç”¨å’ŒæŒ‡é’ˆä»¥å¤–ï¼Œ**å­—é¢å€¼å¸¸é‡ç±»**ä¹Ÿæ˜¯å­—é¢å€¼ç±»å‹
      å’Œå…¶ä»–ç±»ä¸åŒï¼Œå­—é¢å€¼å¸¸é‡ç±»å¯èƒ½å«æœ‰`constexpr`å‡½æ•°æˆå‘˜
      è¿™æ ·çš„æˆå‘˜å¿…é¡»ç¬¦åˆ`constexpr`å‡½æ•°çš„æ‰€æœ‰è¦æ±‚ï¼Œæ˜¯éšå¼`const`çš„
    - ä»¥ä¸‹ç±»æ˜¯å­—é¢å€¼å¸¸é‡ç±»
        - æ•°æ®æˆå‘˜éƒ½æ˜¯å­—é¢å€¼ç±»å‹çš„èšåˆç±»
        - æ»¡è¶³ä»¥ä¸‹è¦æ±‚çš„éèšåˆç±»
            - æ•°æ®æˆå‘˜éƒ½å¿…é¡»æ˜¯å­—é¢å€¼ç±»å‹
            - ç±»å¿…é¡»è‡³å°‘æœ‰ä¸€ä¸ª`constexpr`æ„é€ å‡½æ•°
            - å¦‚æœä¸€ä¸ªæ•°æ®æˆå‘˜å«æœ‰ç±»å†…åˆå§‹å€¼ï¼Œåˆ™å†…ç½®ç±»å‹æˆå‘˜çš„åˆå§‹å€¼å¿…é¡»æ˜¯å¸¸é‡è¡¨è¾¾å¼
              æˆ–è€…å¦‚æœæˆå‘˜å±äºæŸç§ç±»ç±»å‹ï¼Œåˆ™åˆå§‹å€¼å¿…é¡»ä½¿ç”¨æˆå‘˜è‡ªå·±çš„`constexpr`æ„é€ å‡½æ•°
            - ç±»å¿…é¡»ä½¿ç”¨ææ„å‡½æ•°çš„é»˜è®¤å®šä¹‰ï¼Œè¯¥æˆå‘˜è´Ÿè´£é”€æ¯ç±»çš„å¯¹è±¡
    - `constexpr`æ„é€ å‡½æ•°
        - å­—é¢å€¼å¸¸é‡ç±»çš„æ„é€ å‡½æ•°å¯ä»¥æ˜¯`constexpr`ï¼Œä¸”å¿…é¡»æœ‰è‡³å°‘ä¸€ä¸ª`constexpr`æ„é€ å‡½æ•°
        - `constexpr`æ„é€ å‡½æ•°å¯ä»¥å£°æ˜æˆ`= default;`çš„æˆ–è€…`= delete;`çš„
        - `constexpr`æ„é€ å‡½æ•°çš„å‡½æ•°ä½“æ˜¯**ç©ºçš„**
            - æ—¢è¦æ»¡è¶³æ„é€ å‡½æ•°çš„è¦æ±‚ï¼ˆä¸èƒ½æœ‰è¿”å›è¯­å¥ï¼‰
            - åˆè¦æ»¡è¶³`constexpr`å‡½æ•°çš„è¦æ±‚ï¼ˆå‡½æ•°ä½“ä¸­å¦‚æœ‰å¯æ‰§è¡Œè¯­å¥ï¼Œåªèƒ½æ˜¯**ä¸€æ¡**`return`è¯­å¥ï¼‰
        - `constexpr`æ„é€ å‡½æ•°å¿…é¡»åˆå§‹åŒ–**æ‰€æœ‰**æ•°æ®æˆå‘˜ï¼Œåˆå§‹å€¼æˆ–è€…ä½¿ç”¨`constexpr`æ„é€ å‡½æ•°ï¼Œæˆ–è€…æ˜¯ä¸€æ¡å¸¸é‡è¡¨è¾¾å¼
        - `constexpr`æ„é€ å‡½æ•°ç”¨äºç”Ÿæˆ`constexpr`å¯¹è±¡ä»¥åŠ`constexpr`å‡½æ•°çš„å‚æ•°æˆ–è¿”å›ç±»å‹
        ```
        class Debug 
        {
        public:
            constexpr Debug(bool b = true): hw(b), io(b), other(b) {}
            constexpr Debug(bool h, bool i, bool o): hw(h), io(i), other(o) {}
            
            constexpr bool any() { return hw || io || other; }
            
            void set_io(bool b) { io = b; }
            void set_hw(bool b) { hw = b; }
            void set_other(bool b) { hw = b; }
            
        private:
            bool hw;                                 // hardware errors other than IO errors
            bool io;                                 // IO errors
            bool other;                              // other errors
        };
        
        constexpr Debug io_sub(false, true, false);  // debugging IO
        
        if (io_sub.any())                            // equivalent to if(true)
        {
            std::cerr << "print appropriate error messages" << std::endl;
        }    
            
        constexpr Debug prod(false);                 // no debugging during production
        
        if (prod.any())                              // equivalent to if(false)
        {
            std::cerr << "print an error message" << std::endl;
        }
        ```

#### ç±»çš„é™æ€æˆå‘˜

- å£°æ˜
    - é€šè¿‡åœ¨æˆå‘˜å£°æ˜ä¹‹å‰åŠ ä¸Š`static`ä½¿å¾—å…¶ä¸ç±»å…³è”åœ¨ä¸€èµ·
    - é™æ€æˆå‘˜å¯ä»¥æ˜¯`public`ã€`private`æˆ–è€…`protected`çš„
    - é™æ€æ•°æ®æˆå‘˜çš„ç±»å‹å¯ä»¥æ˜¯å¸¸é‡ã€å¼•ç”¨ã€æŒ‡é’ˆã€ç±»ç±»å‹ç­‰ç­‰
- å®šä¹‰
    - å’Œå…¶ä»–æˆå‘˜å‡½æ•°ä¸€æ ·ï¼Œæ—¢å¯ä»¥åœ¨ç±»å†…éƒ¨ï¼Œä¹Ÿå¯ä»¥åœ¨ç±»å¤–éƒ¨å®šä¹‰é™æ€æˆå‘˜å‡½æ•°
    - `static`å…³é”®å­—åªèƒ½å‡ºç°åœ¨ç±»å†…éƒ¨çš„å£°æ˜è¯­å¥ï¼Œåœ¨ç±»å¤–éƒ¨å®šä¹‰é™æ€æˆå‘˜æ—¶ï¼Œ**ä¸èƒ½**é‡å¤
    - é™æ€æˆå‘˜åªèƒ½åœ¨**ç±»å¤–**å®šä¹‰å¹¶åˆå§‹åŒ–ï¼Œä¸”åªèƒ½è¢«å®šä¹‰**ä¸€æ¬¡**ï¼›é™¤`constexpr`é™æ€æˆå‘˜å¤–ï¼Œ**ä¸èƒ½**åœ¨ç±»å†…åˆå§‹åŒ–ï¼Œ**ä¸**ç”±æ„é€ å‡½æ•°åˆå§‹åŒ–
        - è¦æƒ³ç¡®ä¿åªå®šä¹‰ä¸€æ¬¡ï¼Œåº”æŠŠé™æ€æ•°æ®æˆå‘˜çš„å®šä¹‰ä¸å…¶ä»–éå†…è”å‡½æ•°çš„å®šä¹‰æ”¾åœ¨**åŒä¸€ä¸ªæ–‡ä»¶**ä¸­
        - ä»ç±»åå¼€å§‹ï¼Œå°±å·²ç»æ˜¯ç±»çš„ä½œç”¨åŸŸä¹‹å†…äº†ï¼Œæ‰€ä»¥
            - `initRate()`**ä¸ç”¨**å†åŠ ç±»å
            - å¯ä»¥è®¿é—® *ç§æœ‰æˆå‘˜* 
        ```
        double Account::interestRate = initRate();
        ```
        - å³ä½¿ä¸€ä¸ª`constexpr`é™æ€æˆå‘˜åœ¨ç±»å†…éƒ¨è¢«åˆå§‹åŒ–äº†ï¼Œä¹Ÿåº”è¯¥åœ¨ç±»å¤–å®šä¹‰ä¸€ä¸‹è¯¥æˆå‘˜ï¼ˆæ­¤æ—¶**ä¸èƒ½**å†æŒ‡å®šåˆå§‹å€¼ï¼‰
        ```
        // Account.h 
        
        class Account 
        {
        public:
            static double rate() { return interestRate; }
            static void rate(double);
            
        private:
            static constexpr int period = 30;  // period is a constant expression
            double daily_tbl[period];
        };
        
        // Account.cpp
        
        // definition of a static member with no initializer
        constexpr int Account::period;         // initializer provided in the class definition
        ```
    - ç±»ä¼¼äº *å…¨å±€å˜é‡* ï¼Œé™æ€æ•°æ®æˆå‘˜å®šä¹‰åœ¨ä»»ä½•å‡½æ•°ä¹‹å¤–ï¼›ä¸€æ—¦è¢«å®šä¹‰ï¼Œå°±ä¼š *ä¸€ç›´å­˜åœ¨* 
- æ•ˆæœ
    - ç±»çš„é™æ€æˆå‘˜å­˜åœ¨äºå¯¹è±¡ä¹‹å¤–ï¼Œå¯¹è±¡ä¸­ä¸åŒ…å«ä»»ä½•ä¸é™æ€æ•°æ®æˆå‘˜ç›¸å…³çš„æ•°æ®
    - ç±»çš„é™æ€æˆå‘˜è¢«å…¶æ‰€æœ‰å®ä¾‹å…±äº«
    - é™æ€æˆå‘˜å‡½æ•°ä¹Ÿä¸ä¸å¯¹è±¡ç»‘å®šï¼Œ**ä¸èƒ½**ä½¿ç”¨`this`æŒ‡é’ˆï¼Œ**ä¸èƒ½**å£°æ˜æˆ`const`çš„
- ä½¿ç”¨
    - ä½¿ç”¨ä½œç”¨åŸŸè¿ç®—åº¦ç›´æ¥è®¿é—®é™æ€æˆå‘˜
    ```
    double r = Account::rate();
    ```
    - å¯ä»¥ä½¿ç”¨ç±»çš„å¯¹è±¡ã€å¼•ç”¨æˆ–è€…æŒ‡é’ˆæ¥è®¿é—®é™æ€æˆå‘˜
    ```
    Account ac1;
    Account * ac2 = &ac1;
    // equivalent ways to call the static member rate function
    r = ac1.rate();   // through an Account object or reference
    r = ac2->rate();  // through a pointer to an Account object
    ```
    - *æˆå‘˜å‡½æ•°* ä¸é€šè¿‡ä½œç”¨åŸŸè¿ç®—ç¬¦å°±èƒ½ç›´æ¥ä½¿ç”¨é™æ€æˆå‘˜
    ```
    class Account 
    {
    public:
        void calculate() { amount += amount * interestRate; }
        
    private:
        static double interestRate;
    };
    ```
- é™æ€æˆå‘˜èƒ½ç”¨äºæŸäº›åœºæ™¯ï¼Œè€Œæ™®é€šæˆå‘˜ä¸èƒ½
    - é™æ€æ•°æ®æˆå‘˜å¯ä»¥æ˜¯ *ä¸å®Œå…¨ç±»å‹* 
        - ç‰¹åˆ«åœ°ï¼Œé™æ€æ•°æ®æˆå‘˜å¯ä»¥æ˜¯ *å…¶æ‰€å±çš„ç±»ç±»å‹* 
        - éé™æ€æˆå‘˜åªèƒ½æ˜¯ *å…¶æ‰€å±çš„ç±»ç±»å‹* çš„ *æŒ‡é’ˆ* æˆ– *å¼•ç”¨* 
    ```
    class Bar 
    {
    public:
        // ...
        
    private:
        static Bar mem1;  // ok: static member can have incomplete type
        Bar * mem2;       // ok: pointer member can have incomplete type
        Bar mem3;         // error: data members must have complete type
    }
    ```
    - å¯ä»¥ä½¿ç”¨é™æ€æˆå‘˜ä½œä¸º *é»˜è®¤å®å‚* 
        - éé™æ€æˆå‘˜ä¸èƒ½ä½œä¸ºé»˜è®¤å®å‚ï¼Œå› ä¸ºå®ƒçš„å€¼æœ¬èº«å±äºå¯¹è±¡çš„ä¸€éƒ¨åˆ†
          ç»“æœå°±æ˜¯æ— æ³•çœŸæ­£æä¾›ä¸€ä¸ªå¯¹è±¡ä»¥ä¾¿ä»ä¸­è·å–æˆå‘˜çš„å€¼ï¼Œä»è€Œå¼•å‘é”™è¯¯
    ```
    class Screen 
    {
    public:
        // bkground refers to the static member
        // declared later in the class definition
        Screen & clear(char = bkground);
        
    private:
        static const char bkground;
    };
    ```

### ğŸŒ± [Chap 13] ç±»ï¼ˆæ‹·è´æ§åˆ¶ï¼‰

- 

### ğŸŒ± [Chap 14] ç±»ï¼ˆæ“ä½œé‡è½½ä¸ç±»å‹è½¬æ¢ï¼‰

- 

### ğŸŒ± [Chap 15] ç±»ï¼ˆ`OOP`ï¼‰

- 

### ğŸŒ± [Chap 16] ç±»ï¼ˆæ¨¡æ¿ä¸æ³›å‹ç¼–ç¨‹ï¼‰

- 

### ğŸŒ± [Chap 9] [é¡ºåºå®¹å™¨](https://en.cppreference.com/w/cpp/container)ï¼ˆSequential Containerï¼‰


#### ç±»å‹

- é¡ºåºå®¹å™¨ç±»å‹
    - [`std::vector`](https://en.cppreference.com/w/cpp/container/vector)ï¼š
      å¯å˜å¤§å°æ•°ç»„ã€‚æ”¯æŒå¿«é€Ÿéšæœºè®¿é—®ã€‚åœ¨å°¾éƒ¨ä¹‹å¤–çš„ä½ç½®æ’å…¥åˆ é™¤å…ƒç´ å¯èƒ½å¾ˆæ…¢
    - [`std::string`](https://en.cppreference.com/w/cpp/string/basic_string)ï¼š
      ä¸`std::vector`ç›¸ä¼¼ï¼Œä¸“é—¨ç”¨äºä¿å­˜å­—ç¬¦ã€‚éšæœºè®¿é—®å¿«ã€‚åœ¨å°¾éƒ¨æ’å…¥åˆ é™¤é€Ÿåº¦å¿«
    - [`std::deque`](https://en.cppreference.com/w/cpp/container/deque)ï¼š
      åŒç«¯é˜Ÿåˆ—ã€‚æ”¯æŒå¿«é€Ÿéšæœºè®¿é—®ã€‚åœ¨å¤´å°¾æ’å…¥åˆ é™¤å…ƒç´ å¾ˆå¿«
    - [`std::list`](https://en.cppreference.com/w/cpp/container/list)ï¼š
      åŒå‘é“¾è¡¨ã€‚åªæ”¯æŒåŒå‘**é¡ºåº**è®¿é—®ã€‚åœ¨ä»»ä½•ä½ç½®æ’å…¥åˆ é™¤å…ƒç´ éƒ½å¾ˆå¿«
    - [`std::foward_list`](https://en.cppreference.com/w/cpp/container/forward_list)ï¼š
      å•å‘é“¾è¡¨ã€‚åªæ”¯æŒåŒå‘**é¡ºåº**è®¿é—®ã€‚åœ¨ä»»ä½•ä½ç½®æ’å…¥åˆ é™¤å…ƒç´ éƒ½å¾ˆå¿«
    - [`std::array`](https://en.cppreference.com/w/cpp/container/array)ï¼š
      *å›ºå®šå¤§å°* æ•°ç»„ã€‚æ”¯æŒå¿«é€Ÿéšæœºè®¿é—®ã€‚**ä¸èƒ½**æ·»åŠ åˆ é™¤å…ƒç´ ã€‚**æ”¯æŒæ‹·è´èµ‹å€¼**ï¼ˆå†…ç½®æ•°ç»„ä¸è¡Œï¼‰
    ```
    std::array<int, 10> ia1; // ten default-initialized ints
    std::array<int, 10> ia2 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};     // list initialization
    std::array<int, 10> ia3 = {42};                               // ia3[0] is 42, remaining elements are 0

    int digs[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int cpy[10] = digs;                                           // error: no copy or assignment for built-in arrays
    std::array<int, 10> digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    std::array<int, 10> copy = digits;                            // ok: so long as array types match
    ```
- é™¤`std::array`å¤–ï¼Œå…¶ä»–å®¹å™¨å‡æä¾›é«˜æ•ˆçµæ´»çš„å†…å­˜ç®¡ç†
- é™¤`std::foward_list`æ²¡æœ‰`size()`æ“ä½œï¼ˆä¸ºäº†è¾¾åˆ°ä¸æ‰‹å†™çš„å•å‘é“¾è¡¨ä¸€æ ·çš„æ•ˆç‡ï¼‰å¤–ï¼Œå…¶ä½™å®¹å™¨å‡ä¸ºå¸¸æ•°å¤æ‚åº¦
- é¡ºåºå®¹å™¨æ„é€ å‡½æ•°çš„ä¸€ä¸ªç‰ˆæœ¬æ¥å—å®¹å™¨å¤§å°å‚æ•°ï¼Œå®ƒä½¿ç”¨äº†å…ƒç´ ç±»å‹çš„**é»˜è®¤**æ„é€ å‡½æ•°
  å¯¹äºæ²¡æœ‰é»˜è®¤æ„é€ å‡½æ•°çš„ç±»å‹çš„å®¹å™¨ï¼Œæ„é€ æ—¶è¿˜éœ€ä¼ é€’å…ƒç´ åˆå§‹åŒ–å™¨
```
std::vector<noDefault> v1(10, init);  // æ­£ç¡®ï¼šæä¾›äº†å…ƒç´ åˆå§‹åŒ–å™¨
std::vector<noDefault> v2(10);        // é”™è¯¯ï¼šå¿…é¡»æä¾›ä¸€ä¸ªå…ƒç´ åˆå§‹åŒ–å™¨
```

#### å®¹å™¨æ“ä½œ

- ç±»å‹åˆ«åï¼ˆå‡ä¸ºå®¹å™¨ç±» *é™æ€* æˆå‘˜ï¼‰
    - `iterator`ï¼šæ­¤ç±»å‹å®¹å™¨çš„è¿­ä»£å™¨ç±»å‹
        - å¯¹äºå®¹å™¨å¸¸é‡ï¼Œåªèƒ½è·å–å¸¸é‡è¿­ä»£å™¨
    - `const_iterator`ï¼šå¯ä»¥è¯»å–å…ƒç´ ï¼Œä½†ä¸èƒ½ä¿®æ”¹å…ƒç´ çš„è¿­ä»£å™¨ç±»å‹
    - `reverse_iterator`ï¼šæŒ‰é€†åºå¯»å€å…ƒç´ çš„è¿­ä»£å™¨ï¼Œ**ä¸æ”¯æŒ**`std::foward_list`
    - `const_reverse_iterator`ï¼šä¸èƒ½ä¿®æ”¹çš„é€†åºè¿­ä»£å™¨ï¼Œ**ä¸æ”¯æŒ**`std::foward_list`
    - `size_type`ï¼š`size_t` aka `unsigned long`ï¼Œè¶³å¤Ÿä¿å­˜æ­¤ç§å®¹å™¨ç±»å‹æœ€å¤§å¯èƒ½å®¹å™¨çš„å¤§å°
    - `difference_type`ï¼š`ptrdiff_t` aka `long int`ï¼Œè¶³å¤Ÿä¿å­˜ä¸¤ä¸ªè¯¥å®¹å™¨ç±»å‹çš„ *è¿­ä»£å™¨ä¹‹é—´* çš„è·ç¦»
    - `value_type`ï¼šå…ƒç´ ç±»å‹
    - `reference`ï¼šå…ƒç´ çš„å·¦å€¼å¼•ç”¨ç±»å‹ï¼Œç­‰ä»·äº`value_type &`
    - `const_reference`ï¼šå…ƒç´ çš„å¸¸å¼•ç”¨ç±»å‹ï¼Œç­‰ä»·äº`const value_type &`
- æ„é€ å‡½æ•°
    - `C c`ï¼šé»˜è®¤æ„é€ å‡½æ•°ï¼Œæ„é€ ç©ºå®¹å™¨
    - `C c1(c2)`ï¼šæ‹·è´æ„é€ ï¼Œå°†`c2`ä¸­æ‰€æœ‰å…ƒç´ æ‹·è´åˆ°`c1`
    - `C c(b, e)`ï¼šæ„é€ `c`ï¼Œå°†è¿­ä»£å™¨`b`å’Œ`e`æŒ‡å®šçš„èŒƒå›´å†…çš„å…ƒç´ æ‹·è´åˆ°`c`ã€‚**ä¸æ”¯æŒ**`std::array`
        - å°†å®¹å™¨åˆå§‹åŒ–ä¸ºå¦ä¸€å®¹å™¨çš„æ‹·è´æ—¶ï¼Œä¸¤ä¸ªå®¹å™¨çš„å®¹å™¨ç±»å‹å’Œå…ƒç´ ç±»å‹éƒ½å¿…é¡»ç›¸åŒ
        - å¦‚æœç”¨è¿­ä»£å™¨æŒ‡å®šèŒƒå›´ï¼Œåˆ™ä»…å…ƒç´ ç±»å‹ç›¸åŒå³å¯
    - `C c{a, b, c...}`æˆ–`C c = {a, b, c...};`ï¼šåˆ—è¡¨åˆå§‹åŒ–
    - å¤§å°ç›¸å…³æ„é€ å‡½æ•°
        - åªæœ‰é¡ºåºå®¹å™¨æ‰æ¥å—å¤§å°å‚æ•°ï¼› *å…³è”å®¹å™¨* **ä¸æ”¯æŒ**
- èµ‹å€¼ä¸`swap`
    - `c1 = c2`ï¼šå°†`c1`ä¸­çš„å…ƒç´ å…¨éƒ¨æ›¿æ¢ä¸º`c2`ä¸­çš„å…ƒç´ 
    - `c1 = {a, b, c...}`ï¼šå°†`c1`ä¸­çš„å…ƒç´ æ›¿æ¢ä¸ºåˆ—è¡¨ä¸­çš„å…ƒç´ ã€‚**ä¸æ”¯æŒ**`std::array`
    - `a.swap(b)`ï¼šäº¤æ¢`a`ä¸`b`ä¸­çš„å…ƒç´ 
    - `std::swap(a, b)`ï¼šäº¤æ¢`a`ä¸`b`ä¸­çš„å…ƒç´ 
- å¤§å°
    - `c.size()`ï¼š`c`ä¸­å…ƒç´ çš„æ•°ç›®ã€‚å¸¸æ•°å¤æ‚åº¦ã€‚**ä¸æ”¯æŒ**`std::foward_list`
    - `c.max_size()`ï¼š`c`å¯ä¿å­˜çš„æœ€å¤§å…ƒç´ æ•°ç›®
    - `c.empty()`ï¼šè‹¥`c`ä¸­å­˜å‚¨äº†å…ƒç´ ï¼Œè¿”å›`false`ï¼Œå¦åˆ™è¿”å›`true`
- æ·»åŠ åˆ é™¤å…ƒç´ ï¼ˆ**ä¸æ”¯æŒ**`std::array`ï¼‰
    - `c.insert(args)`ï¼šå°†`args`ä¸­çš„å…ƒç´ æ‹·è´è¿›`c`
    - `c.emplace(init)`ï¼šä½¿ç”¨`inits`æ„é€ `c`ä¸­çš„ä¸€ä¸ªå…ƒç´ 
    - `c.erase(args)`ï¼šåˆ é™¤`args`æŒ‡å®šçš„å…ƒç´ 
    - `c.clear()`ï¼šåˆ é™¤`c`ä¸­æ‰€æœ‰å…ƒç´ ï¼Œè¿”å›`void`
- å…³ç³»è¿ç®—ç¬¦
    - `==`ï¼Œ`!=`ï¼šæ‰€æœ‰å®¹å™¨éƒ½æ”¯æŒç›¸ç­‰å’Œä¸ç­‰è¿ç®—ç¬¦
    - `<`ï¼Œ`<=`ï¼Œ`>`ï¼Œ`>=`ï¼šå…³ç³»è¿ç®—ç¬¦ã€‚**ä¸æ”¯æŒ**æ— åºå…³è”å®¹å™¨
- è·å–è¿­ä»£å™¨
    - `c.begin()`ï¼Œ`c.end()`ï¼šè¿”å›æŒ‡å‘`c`çš„é¦–å…ƒç´ å’Œå°¾å“¨å…µçš„è¿­ä»£å™¨ï¼ˆâ€œå°¾åè¿­ä»£å™¨â€ï¼Œoff-the-end iteratorï¼‰
    - `c.cbegin()`ï¼Œ`c.cend()`ï¼šè¿”å›`const_iterator`
    - `c.rbegin()`ï¼Œ`c.rend()`ï¼šè¿”å›æŒ‡å‘`c`çš„å°¾å…ƒç´ å’Œå¤´å“¨å…µçš„è¿­ä»£å™¨ã€‚**ä¸æ”¯æŒ**`std::foward_list`
    - `c.crbegin()`ï¼Œ`c.crend()`ï¼šè¿”å›`const_reverse_iterator`ã€‚**ä¸æ”¯æŒ**`std::foward_list`
    - `std::begin()`ï¼Œ`std::end()`ï¼šä¸ä½†èƒ½ç”¨äºå®¹å™¨ï¼Œ *è¿˜èƒ½ç”¨äºå†…ç½®æ•°ç»„* 
    ```
    std::vector<int> vec{0, 1, 2, 3};
    std::vector<int>::iterator iter_beg = std::begin(vec);
    std::vector<int>::iterator iter_end = std::end(vec);
    
    int arr[] = {0, 1, 2, 3};
    int * ptr_beg = std::begin(arr);
    int * ptr_end = std::end(arr);
    ```

#### è¿­ä»£å™¨ï¼ˆiteratorï¼‰

- æ‰€æœ‰æ ‡å‡†åº“å®¹å™¨éƒ½æ”¯æŒè¿­ä»£å™¨ï¼Œä½†åªæœ‰å°‘æ•°å‡ ç§æ‰åŒæ—¶æ”¯æŒä¸‹æ ‡è¿ç®—ç¬¦
- å¦‚æœå®¹å™¨ä¸ºç©ºï¼Œåˆ™`begin`å’Œ`end`è¿”å›çš„æ˜¯**åŒä¸€ä¸ª**è¿­ä»£å™¨ï¼Œéƒ½æ˜¯å°¾åè¿­ä»£å™¨
- `for each`å¾ªç¯å†…ä»¥åŠä½¿ç”¨è¿­ä»£å™¨æ—¶**ä¸èƒ½**æ”¹å˜è¢«éå†çš„å®¹å™¨çš„å¤§å°
- è¿­ä»£å™¨è¿ç®—ç¬¦
    - `*iter`ï¼šè¿”å›è¿­ä»£å™¨`iter`æ‰€çŸ¥å…ƒç´ çš„**å·¦å€¼**å¼•ç”¨
        - è§£å¼•ç”¨ *éæ³•* è¿­ä»£å™¨æˆ–è€… *å°¾å* è¿­ä»£å™¨æ˜¯**æœªå®šä¹‰è¡Œä¸º**
    - `iter->mem`ï¼šè§£å¼•ç”¨`iter`å¹¶è·å–è¯¥å…ƒç´ åä¸º`mem`çš„æˆå‘˜ï¼Œç­‰ä»·äº`(*iter).mem`
    - `++iter`ï¼šä»¤`iter`æŒ‡å‘å®¹å™¨ä¸­çš„ä¸‹ä¸€ä¸ªå…ƒç´ 
        - å°¾åè¿­ä»£å™¨å¹¶ä¸å®é™…æŒ‡å‘å…ƒç´ ï¼Œå› æ­¤**ä¸èƒ½**é€’å¢æˆ–é€’å‡
        - è‡³å°‘`g++`å…è®¸è‡ªå‡å°¾åè¿­ä»£å™¨`--c.end()`è·å–å°¾å…ƒç´ 
    - `--iter`ï¼šä»¤`iter`æŒ‡å‘å®¹å™¨ä¸­çš„ä¸Šä¸€ä¸ªå…ƒç´ 
    - `iter1 == iter2`ï¼Œ`iter1 != iter2`ï¼šåˆ¤æ–­ä¸¤ä¸ªè¿­ä»£å™¨æ˜¯å¦ç›¸ç­‰ï¼ˆä¸ç›¸ç­‰ï¼‰ã€‚
                                          å¦‚æœä¸¤ä¸ªè¿­ä»£å™¨æŒ‡å‘çš„æ˜¯åŒä¸€ä¸ªå…ƒç´ ï¼Œæˆ–è€…å®ƒä»¬æ˜¯åŒä¸€ä¸ªå®¹å™¨çš„å°¾åè¿­ä»£å™¨ï¼Œ
                                          åˆ™ç›¸ç­‰ï¼›åä¹‹ï¼Œä¸ç›¸ç­‰ã€‚
- è¿­ä»£å™¨ç®—æœ¯è¿ç®—ï¼ˆiterator arithmeticï¼‰
    - `iter + n`ï¼šç»“æœä»ä¸ºè¿­ä»£å™¨ï¼Œæˆ–æŒ‡å‘å®¹å™¨ä¸­å…ƒç´ ï¼Œæˆ–æŒ‡å‘å°¾å
    - `iter - n`ï¼šç»“æœä»ä¸ºè¿­ä»£å™¨ï¼Œæˆ–æŒ‡å‘å®¹å™¨ä¸­å…ƒç´ ï¼Œæˆ–æŒ‡å‘å°¾å
    - `iter += n`
    - `iter1 - iter2`ï¼šä¸¤ä¸ªè¿­ä»£å™¨ä¹‹é—´çš„è·ç¦»ï¼ˆ`difference_type`ï¼‰ï¼Œ
                       å³ï¼šå°†`iter2`å‘å‰ç§»åŠ¨`iter1 - iter2`ä¸ªå…ƒç´ ï¼Œå°†å¾—åˆ°`iter1`ï¼›
    - `<`ï¼Œ`<=`ï¼Œ`>`ï¼Œ`>=`ï¼šå…³ç³»è¿ç®—ç¬¦ã€‚å‚ä¸è¿ç®—çš„ä¸¤ä¸ªè¿­ä»£å™¨å¿…é¡»æ˜¯åˆæ³•çš„ï¼ˆæˆ–æŒ‡å‘å®¹å™¨ä¸­å…ƒç´ ï¼Œæˆ–æŒ‡å‘å°¾åï¼‰ã€‚
                            å¦‚æœå‰è€…æŒ‡å‘çš„å®¹å™¨ä½ç½®åœ¨åè€…æŒ‡å‘çš„å®¹å™¨ä½ç½®ä¹‹å‰ï¼Œåˆ™å‰è€…å°äºåè€…
    - æ³¨æ„äº‹é¡¹
        - **ä¸**æ”¯æŒ`std::list`ã€`std::forward_list`
        - å› ä¸ºåŒå‘é“¾è¡¨å’Œå•å‘é“¾è¡¨å­˜å‚¨å…ƒç´ éƒ½ *ä¸åœ¨ä¸€å—è¿ç»­çš„å†…å­˜ä¸Š* ï¼Œæ‰€ä»¥æ— æ³•é€šè¿‡åŠ å‡æ³•æŒ‰è·ç¦»æŸ¥æ‰¾å…ƒç´ 
- è‡ªå®šä¹‰ *æ„æˆèŒƒå›´* çš„è¿­ä»£å™¨`begin`å’Œ`end`**å¿…é¡»æ»¡è¶³**çš„è¦æ±‚
    - å®ƒä»¬æˆ–æŒ‡å‘åŒä¸€å®¹å™¨ä¸­çš„å…ƒç´ ï¼Œæˆ–æŒ‡å‘åŒä¸€å®¹å™¨çš„å°¾å
    - `begin <= end`ï¼Œå³ï¼š`end`ä¸åœ¨`begin`ä¹‹å‰

#### å®¹å™¨æ“ä½œå¯èƒ½å¯¼è‡´è¿­ä»£å™¨ã€å¼•ç”¨å’ŒæŒ‡é’ˆå¤±æ•ˆ

- æ€»åˆ™
    - æ€»è€Œè¨€ä¹‹ï¼Œå®¹å™¨å¤§å°ä¸€æ—¦åŠ¨äº†ï¼Œåˆ™ *æ‰€æœ‰* æŒ‡å‘æ­¤å®¹å™¨çš„è¿­ä»£å™¨ã€å¼•ç”¨å’ŒæŒ‡é’ˆéƒ½ *å¯èƒ½* å¤±æ•ˆï¼Œæ‰€ä»¥ä¸€å¾‹æ›´æ–°ä¸€æ³¢æ‰æ˜¯ *å å¼çš„* 
    - æ­¤å¤–ï¼Œæ°¸è¿œ**ä¸è¦ç¼“å­˜**å°¾åè¿­ä»£å™¨ï¼ˆè¿™ç©æ„å¸¸å¹´å˜æ¥å˜å»ï¼‰ï¼Œç°ç”¨ç°åˆ¶ï¼Œç”¨åå³å¼ƒï¼Œ`end()`çš„å®ç°éƒ½æ˜¯å¾ˆå¿«çš„
- è¾¨æ
    - æ’å…¥å…ƒç´ 
        - å¯¹äº`std::vector`å’Œ`std::string`ï¼Œå¦‚æœå­˜å‚¨ç©ºé—´ *é‡æ–°åˆ†é…* ï¼Œåˆ™ *æ‰€æœ‰* æŒ‡å‘æ­¤å®¹å™¨çš„è¿­ä»£å™¨ã€å¼•ç”¨å’ŒæŒ‡é’ˆ**éƒ½ä¼šå¤±æ•ˆ**ã€‚å¦‚æœ *æœªé‡æ–°åˆ†é…* ï¼ŒæŒ‡å‘ *æ’å…¥ä½ç½®ä¹‹å‰* çš„å…ƒç´ çš„è¿­ä»£å™¨ã€ å¼•ç”¨å’ŒæŒ‡é’ˆ *ä»æœ‰æ•ˆ* ï¼Œä½†æŒ‡å‘ *æ’å…¥ä½ç½®ä¹‹å* çš„å…ƒç´ çš„è¿­ä»£å™¨ã€ å¼•ç”¨å’ŒæŒ‡é’ˆ**éƒ½ä¼šå¤±æ•ˆ**
        - å¯¹äº`std::deque`ï¼Œæ’å…¥åˆ°é¦–å°¾ä½ç½®ä¹‹å¤–çš„ä»»ä½•ä½ç½®éƒ½ä¼šå¯¼è‡´ *æ‰€æœ‰* æŒ‡å‘æ­¤å®¹å™¨çš„è¿­ä»£å™¨ã€å¼•ç”¨å’ŒæŒ‡é’ˆ**å¤±æ•ˆ**ã€‚å¦‚æœåœ¨é¦–å°¾ä½ç½®æ·»åŠ å…ƒç´ ï¼Œåˆ™ *è¿­ä»£å™¨* ä¼š**å¤±æ•ˆ**ï¼Œä½†æŒ‡å‘ *å­˜åœ¨çš„å…ƒç´ * çš„ *å¼•ç”¨* å’Œ *æŒ‡é’ˆ* *ä»æœ‰æ•ˆ*
        - å¯¹äº`std::list`å’Œ`std::foward_list`ï¼ŒæŒ‡å‘å®¹å™¨çš„è¿­ä»£å™¨ï¼ˆåŒ…æ‹¬é¦–å‰å’Œå°¾åè¿­ä»£å™¨ï¼‰ã€æŒ‡é’ˆå’Œå¼•ç”¨ *ä»æœ‰æ•ˆ*
    - åˆ é™¤å…ƒç´ 
        - å¯¹äº`std::vector`å’Œ`std::string`ï¼ŒæŒ‡å‘ *è¢«åˆ é™¤å…ƒç´ ä¹‹å‰* çš„å…ƒç´ çš„è¿­ä»£å™¨ã€ å¼•ç”¨å’ŒæŒ‡é’ˆ *ä»æœ‰æ•ˆ* ï¼Œä½†æŒ‡å‘ *æ’å…¥ä½ç½®ä¹‹å* çš„å…ƒç´ çš„è¿­ä»£å™¨ã€ å¼•ç”¨å’ŒæŒ‡é’ˆ**éƒ½ä¼šå¤±æ•ˆ**ã€‚ *å°¾åè¿­ä»£å™¨* **ä¸€å®šä¼šå¤±æ•ˆ**
        - å¯¹äº`std::deque`ï¼Œåœ¨é¦–å°¾ä½ç½®ä¹‹å¤–çš„ä»»ä½•ä½ç½®åˆ é™¤å…ƒç´ éƒ½ä¼šå¯¼è‡´ *æ‰€æœ‰* æŒ‡å‘æ­¤å®¹å™¨çš„è¿­ä»£å™¨ã€å¼•ç”¨å’ŒæŒ‡é’ˆ**å¤±æ•ˆ**ã€‚å¦‚æœåˆ é™¤ *å°¾å…ƒç´ * ï¼Œåˆ™ *å°¾åè¿­ä»£å™¨* ä¹Ÿä¼š**å¤±æ•ˆ**ï¼Œä½† *å…¶ä»–* *è¿­ä»£å™¨* ã€ *å¼•ç”¨* å’Œ *æŒ‡é’ˆ* *ä¸å—å½±å“* ï¼›å¦‚æœåˆ é™¤ *é¦–å…ƒç´ * ï¼Œè¿™äº›ä¹Ÿ *ä¸å—å½±å“*
        - å¯¹äº`std::list`å’Œ`std::foward_list`ï¼ŒæŒ‡å‘å®¹å™¨çš„è¿­ä»£å™¨ï¼ˆåŒ…æ‹¬é¦–å‰å’Œå°¾åè¿­ä»£å™¨ï¼‰ã€æŒ‡é’ˆå’Œå¼•ç”¨ *ä»æœ‰æ•ˆ*
    - `resize()`
        - å¦‚æœ`resize()`ç¼©å°å®¹å™¨ï¼Œåˆ™æŒ‡å‘ *è¢«åˆ é™¤å…ƒç´ * çš„ *è¿­ä»£å™¨* ã€ *å¼•ç”¨* å’Œ *æŒ‡é’ˆ* **å¤±æ•ˆ**
        - å¯¹äº`resize()`å¯¼è‡´å­˜å‚¨ç©ºé—´é‡æ–°åˆ†é…ï¼ˆå¯¹äº`std::vector`ï¼Œ`std::string`ä»¥åŠ`std::deque`ï¼‰ï¼Œåˆ™ *æ‰€æœ‰* æŒ‡å‘æ­¤å®¹å™¨çš„ *è¿­ä»£å™¨* ã€ *å¼•ç”¨* å’Œ *æŒ‡é’ˆ* **éƒ½ä¼šå¤±æ•ˆ**

#### å®¹å™¨å®šä¹‰å’Œåˆå§‹åŒ–

- `C c`ï¼šé»˜è®¤æ„é€ å‡½æ•°ã€‚å¦‚æœ`C`æ˜¯ä¸€ä¸ª`std::array`ï¼Œåˆ™`c`ä¸­å…ƒç´ æŒ‰é»˜è®¤æ–¹å¼åˆå§‹åŒ–ï¼›å¦åˆ™`c`ä¸ºç©º
- `C c1(c2)`ï¼Œ`C c1 = c2`ï¼š`c1`åˆå§‹åŒ–ä¸º`c2`çš„æ‹·è´ã€‚
                             `c1`å’Œ`c2`å¿…é¡»æ˜¯**ç›¸åŒç±»å‹**
                             ï¼ˆå³ï¼šç›¸åŒçš„å®¹å™¨ç±»å‹å’Œå…ƒç´ ç±»å‹ï¼Œå¯¹äº`std::array`è¿˜æœ‰ç›¸åŒå¤§å°ï¼‰
- `C c{a, b, c...}`ï¼Œ`C c = {a, b, c...}`ï¼š`c`åˆå§‹åŒ–ä¸ºåˆå§‹åŒ–åˆ—è¡¨ä¸­å…ƒç´ çš„æ‹·è´ã€‚
                                             åˆ—è¡¨ä¸­å…ƒç´ ç±»å‹å¿…é¡»ä¸`C`å…¼å®¹ã€‚
                                             å¯¹äº`std::array`ï¼Œåˆ—è¡¨ä¸­å…ƒç´ æ•°ç›®ä¸å¤§äº`array`å¤§å°ï¼Œ
                                             é—æ¼å…ƒç´ ä¸€å¾‹ *å€¼åˆå§‹åŒ–* 
- `C c(b, e)`ï¼š`c`åˆå§‹åŒ–ä¸ºè¿­ä»£å™¨`b`å’Œ`e`æŒ‡å®šèŒƒå›´ä¸­çš„å…ƒç´ çš„æ‹·è´ã€‚
                èŒƒå›´ä¸­å…ƒç´ çš„ç±»å‹å¿…é¡»ä¸`C`å…¼å®¹ï¼ˆ`std::array`**ä¸é€‚ç”¨**ï¼‰
```
// each container has three elements, initialized from the given initializers
std::list<std::string> authors = {"Milton", "Shakespeare", "Austen"};
std::vector<const char *> articles = {"a", "an", "the"};

std::list<std::string> list2(authors);                                   // ok: types match
std::deque<std::string> authList(authors);                               // error: container types don't match
std::vector<std::string> words(articles);                                // error: element types must match
// ok: converts const char * elements to std::string
std::forward_list<std::string> words(articles.begin(), articles.end());

// copies up to but not including the element denoted by it
std::list<std::string>::iterator it = authors.end();
--it;
std::deque<std::string> authList(authors.begin(), it);
```                   
åªæœ‰ *é¡ºåºå®¹å™¨* ï¼ˆ**ä¸åŒ…æ‹¬**`std::array`ï¼‰çš„æ„é€ å‡½æ•°æ‰èƒ½æ¥å—å¤§å°å‚æ•°
- `C seq(n)`ï¼š`seq`åŒ…å«`n`ä¸ªå…ƒç´ ï¼Œè¿™äº›å…ƒç´ è¿›è¡Œäº† *å€¼åˆå§‹åŒ–* ã€‚æ­¤æ„é€ å‡½æ•°æ˜¯`explicit`çš„ã€‚**ä¸é€‚ç”¨**äº`std::string`
- `C seq(n, t)`ï¼š`seq`åŒ…å«`n`ä¸ªåˆå§‹åŒ–ä¸ºå€¼`t`çš„å…ƒç´ 
```
std::vector<int> ivec(10, -1);      // 10 int elements, each initialized to -1
list<std::string> svec(10, "hi!");  // 10 strings; each element is "hi!"
std::forward_list<int> ivec(10);    // 10 elements, each initialized to 0
std::deque<std::string> svec(10);   // 10 elements, each an empty string
```

#### èµ‹å€¼å’Œ`swap`

- ä»¥ä¸‹èµ‹å€¼è¿ç®—ç¬¦å¯ç”¨äºæ‰€æœ‰å®¹å™¨
    - `c1 = c2`ï¼šå°†`c1`ä¸­çš„å…ƒç´ æ›¿æ¢ä¸º`c2`ä¸­å…ƒç´ çš„æ‹·è´ã€‚`c1`å’Œ`c2`å¿…é¡»å…·æœ‰ç›¸åŒçš„ç±»å‹
    - `c = {a, b, c...}`ï¼šå°†`c1`ä¸­å…ƒç´ æ›¿æ¢ä¸ºåˆå§‹åŒ–åˆ—è¡¨ä¸­å…ƒç´ çš„æ‹·è´ï¼ˆ`std::array`**ä¸é€‚ç”¨**ï¼‰
    ```
    std::array<int, 10> a1 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    std::array<int, 10> a2 = {0};                             // OK: elements all have value 0
    a1 = a2;                                                  // OK: replaces elements in a1
    a2 = {0};                                                 // error: cannot assign to an array 
                                                              //        from a braced list
    ```
    - `std::swap(c1, c2);`ï¼Œ`c1.swap(c2);`ï¼šäº¤æ¢`c1`å’Œ`c2`ä¸­çš„å…ƒç´ ã€‚`c1`å’Œ`c2`å¿…é¡»å…·æœ‰**ç›¸åŒç±»å‹**
        - é™¤`std::array`**ä»¥å¤–**ï¼Œ`swap`ä¸å¯¹ä»»ä½•å…ƒç´ è¿›è¡Œæ‹·è´ï¼Œåˆ é™¤æˆ–æ’å…¥æ“ä½œï¼Œå› æ­¤å¯ä»¥ä¿è¯ *å¸¸æ•°å¤æ‚åº¦* 
        - å…ƒç´ ä¸è¢«ç§»åŠ¨æ„å‘³ç€é™¤`std::array`å’Œ`std::string`**ä»¥å¤–**ï¼ŒåŸå…ˆçš„è¿­ä»£å™¨ã€æŒ‡é’ˆå’Œå¼•ç”¨ *ä¸ä¼šå¤±æ•ˆ* 
        - æ³›å‹ç¼–ç¨‹è¦æ±‚ï¼š**åº”å½“**ç»Ÿä¸€ä½¿ç”¨ *éæˆå‘˜ç‰ˆæœ¬* çš„`swap`ï¼Œå³`std::swap(c1, c2);`
    ```
    std::vector<std::string> svec1(10);  // vector with 10 elements
    std::vector<std::string> svec2(24);  // vector with 24 elements
    std::swap(svec1, svec2);
    ```
- `assign`æ“ä½œ**ä¸é€‚ç”¨äº** *å…³è”å®¹å™¨* ä»¥åŠ`std::array`
    - `seq.assign(b, e);`ï¼šå°†`seq`ä¸­çš„å…ƒç´ æ›¿æ¢ä¸ºè¿­ä»£å™¨`b`å’Œ`e`æ‰€è¡¨ç¤ºèŒƒå›´ä¸­çš„å…ƒç´ ã€‚è¿­ä»£å™¨`b`å’Œ`e`**ä¸èƒ½**æŒ‡å‘`seq`ä¸­çš„å…ƒç´ 
        - ç”±äºæ—§å…ƒç´ è¢« *æ›¿æ¢* ï¼Œå› æ­¤ä¼ é€’ç»™`assign`çš„è¿­ä»£å™¨**ä¸èƒ½**æŒ‡å‘è°ƒç”¨`assign`çš„å®¹å™¨
    ```
    std::list<std::string> names;
    std::vector<const char *> oldstyle;
    names = oldstyle;                                  // error: container types don't match
    names.assign(oldstyle.cbegin(), oldstyle.cend());  // ok: can convert from const char * to string
    ```
    - `seq.assign({a, b, c...})`ï¼šå°†`seq`ä¸­çš„å…ƒç´ æ›¿æ¢ä¸ºåˆå§‹åŒ–åˆ—è¡¨ä¸­çš„å…ƒç´ 
    - `seq.assign(n, t)`ï¼šå°†`seq`ä¸­çš„å…ƒç´ æ›¿æ¢ä¸º`n`ä¸ªå€¼ä¸º`t`çš„å…ƒç´ 
    ```
    // equivalent to: slist1.clear(); 
    //                slist1.insert(slist1.begin(), 10, "Hiya!");
    std::list<std::string> slist1(1); // one element, which is the empty string
    slist1.assign(10, "Hiya!");       // ten elements; each one is Hiya !
    ```
- èµ‹å€¼è¿ç®—ä¼šå¯¼è‡´æŒ‡å‘å·¦è¾¹å®¹å™¨å†…éƒ¨çš„è¿­ä»£å™¨ã€å¼•ç”¨å’ŒæŒ‡é’ˆ**å¤±æ•ˆ**ã€‚è€Œ`swap`æ“ä½œå°†å®¹å™¨å†…å®¹äº¤æ¢ï¼Œ**ä¸ä¼š**å¯¼è‡´æŒ‡å‘å®¹å™¨çš„è¿­ä»£å™¨ã€å¼•ç”¨å’ŒæŒ‡é’ˆå¤±æ•ˆ
    - `std::array`å’Œ`std::string`**é™¤å¤–**

#### å…³ç³»è¿ç®—ç¬¦

- æ¯ä¸ªå®¹å™¨ç±»å‹éƒ½æ”¯æŒ *ç›¸ç­‰è¿ç®—ç¬¦* `==`å’Œ`!=`
- **é™¤** *æ— åºå…³è”å®¹å™¨* **å¤–**ï¼Œæ‰€æœ‰å®¹å™¨éƒ½æ”¯æŒ *å…³ç³»è¿ç®—ç¬¦* `>`ã€`>=`ã€`<`å’Œ`<=`
    - *å…³ç³»è¿ç®—ç¬¦* å·¦å³çš„å®¹å™¨å¿…é¡»ä¸º**ç›¸åŒç±»å‹**
    - æ¯”è¾ƒä¸¤ä¸ªå®¹å™¨çš„æ–¹å¼ä¸`std::string`ç±»ä¼¼ï¼Œä¸º *é€å…ƒç´ å­—å…¸åº* 
    - åªæœ‰å½“å…¶å…ƒç´ ç±»å‹ä¹Ÿå®šä¹‰äº†ç›¸åº”çš„æ¯”è¾ƒè¿ç®—ç¬¦æ—¶ï¼Œæ‰å¯ä»¥ä½¿ç”¨ *å…³ç³»è¿ç®—ç¬¦* æ¥æ¯”è¾ƒä¸¤ä¸ªå®¹å™¨
    ```
    std::vector<int> v1 = {1, 3, 5, 7, 9, 12};
    std::vector<int> v2 = {1, 3, 9};
    std::vector<int> v3 = {1, 3, 5, 7};
    std::vector<int> v4 = {1, 3, 5, 7, 9, 12};
    v1 < v2   // true; v1 and v2 differ at element [2]: v1[2] is less than v2[2]
    v1 < v3   // false; all elements are equal, but v3 has fewer of them;
    v1 == v4  // true; each element is equal and v1 and v4 have the same size()
    v1 == v2  // false; v2 has fewer elements than v1
    ```
    
#### é¡ºåºå®¹å™¨æ“ä½œ

- æ’å…¥å…ƒç´ 
    - `c.push_back(t)`ï¼Œ`c.emplace_back(args)`ï¼šåœ¨`c`çš„å°¾éƒ¨åˆ›å»ºä¸€ä¸ªå€¼ä¸º`t`æˆ–ç”±`args`åˆ›å»ºçš„å…ƒç´ ã€‚è¿”å›`void`
        - `clang`å»ºè®®ï¼šä½¿ç”¨`emplace_back`ï¼Œ**è€Œä¸æ˜¯**`push_back`
    - `c.push_front(t)`ï¼Œ`c.emplace_front(args)`ï¼šåœ¨`c`çš„å¤´éƒ¨åˆ›å»ºä¸€ä¸ªå€¼ä¸º`t`æˆ–ç”±`args`åˆ›å»ºçš„å…ƒç´ ã€‚è¿”å›`void`
    - `c.insert(p, t)`ï¼Œ`c.emplace(p, args)`ï¼šåœ¨è¿­ä»£å™¨`p`æŒ‡å‘çš„å…ƒç´  *ä¹‹å‰* åˆ›å»ºä¸€ä¸ªå€¼ä¸º`t`æˆ–ç”±`args`åˆ›å»ºçš„å…ƒç´ ã€‚è¿”å›æŒ‡å‘æ–°æ·»åŠ çš„å…ƒç´ çš„è¿­ä»£å™¨
        - `emplace`å‡½æ•°åœ¨å®¹å™¨ä¸­ç›´æ¥ *æ„å»º* æ–°å…ƒç´ ã€‚ä¼ é€’ç»™`emplace`å‡½æ•°çš„å‚æ•°å¿…é¡»ä¸å…ƒç´ ç±»å‹çš„æ„é€ å‡½æ•°å‚æ•°ç›¸åŒ¹é…
        ```
        struct Entry 
        {
            Entry() = default;
            Entry(int _k, std::string _v) : k(_k), v(_v) {}
            int k{0};
            std::string v{""};
        };
        
        std::vector<Entry> v;
        
        // ä»¥ä¸‹ç­‰ä»·
        v.push_back(Entry(1, "str1"));
        v.emplace_back(1, "str1");
        
        v.insert(v.end(), Entry(1, "str1"));
        v.emplace(v.end(), 1, "str1");
        ```
    - `c.insert(p, n, t)`ï¼šåœ¨è¿­ä»£å™¨`p`æŒ‡å‘çš„å…ƒç´  *ä¹‹å‰* åˆ›å»º`n`ä¸ªå€¼ä¸º`t`æˆ–ç”±`args`åˆ›å»ºçš„å…ƒç´ ã€‚è¿”å›æŒ‡å‘æ–°æ·»åŠ çš„ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨
    - `c.insert(p, b, e)`ï¼šå°†è¿­ä»£å™¨`b`å’Œ`e`æŒ‡å®šçš„èŒƒå›´å†…çš„å…ƒç´ æ’å…¥åˆ°è¿­ä»£å™¨`p`æŒ‡å‘çš„å…ƒç´  *ä¹‹å‰* ã€‚`b`å’Œ`e`**ä¸èƒ½**æŒ‡å‘`c`ä¸­çš„å…ƒç´ ã€‚è¿”å›æŒ‡å‘æ–°æ·»åŠ ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ï¼›è‹¥èŒƒå›´ä¸ºç©ºï¼Œåˆ™è¿”å›`p`
    - `c.insert(p, {a, b, c...})`ï¼šå°†åˆ—è¡¨`{a, b, c...}`ä¸­çš„ *å…ƒç´ * æ’å…¥åˆ°è¿­ä»£å™¨`p`æŒ‡å‘çš„å…ƒç´  *ä¹‹å‰* ã€‚è¿”å›æŒ‡å‘æ–°æ·»åŠ çš„ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ï¼›è‹¥åˆ—è¡¨ä¸ºç©ºï¼Œè¿”å›`p`
    - æ³¨æ„äº‹é¡¹
        - å‘`std::vector`ã€`std::string`æˆ–`std::deque`æ’å…¥å…ƒç´ ä¼šä½¿ *å¾ˆå¤š* æŒ‡å‘è¯¥å®¹å™¨çš„ *è¿­ä»£å™¨* ã€ *å¼•ç”¨* å’Œ *æŒ‡é’ˆ* **å¤±æ•ˆ**
        - `std::forward_list`æœ‰è‡ªå·±ä¸“å±ç‰ˆæœ¬çš„`insert`å’Œ`emplace`ï¼Œ**ä¸æ”¯æŒ**`push_back`ä»¥åŠ`emplace_back`
        - `std::vector`**ä¸æ”¯æŒ**`push_front`ä»¥åŠ`emplace_front`
        - `std::string`**ä¸æ”¯æŒ**`push_front`ä»¥åŠ`emplace_front`
        - `std::array`**ä¸æ”¯æŒ**ä»¥ä¸Šå…¨éƒ¨
- è®¿é—®å…ƒç´ 
    - `c.back()`ï¼šè¿”å›`c`ä¸­å°¾å…ƒç´ çš„ *å¼•ç”¨* ã€‚è‹¥`c`ä¸ºç©ºï¼Œå‡½æ•°è¡Œä¸º *æœªå®šä¹‰* 
    - `c.front()`ï¼šè¿”å›`c`ä¸­é¦–å…ƒç´ çš„ *å¼•ç”¨* ã€‚è‹¥`c`ä¸ºç©ºï¼Œå‡½æ•°è¡Œä¸º *æœªå®šä¹‰* 
    - `c[i]`ï¼šè¿”å›`c`ä¸­ä¸‹æ ‡ä¸º`i`çš„å…ƒç´ çš„ *å¼•ç”¨* ã€‚è‹¥ä¸‹æ ‡è¶Šç•Œï¼Œå‡½æ•°è¡Œä¸º *æœªå®šä¹‰* 
    - `c.at(i)`ï¼šè¿”å›`c`ä¸­ä¸‹æ ‡ä¸º`i`çš„å…ƒç´ çš„ *å¼•ç”¨* ã€‚è‹¥ä¸‹æ ‡è¶Šç•Œï¼Œåˆ™æŠ›å‡º`out_of_range`å¼‚å¸¸
    - æ³¨æ„äº‹é¡¹
        - å¯¹ *ç©ºå®¹å™¨* ä½¿ç”¨`front()`æˆ–è€…`back()`å°±åƒä¸‹æ ‡è¶Šç•Œä¸€æ ·ï¼Œæ˜¯ä¸€ç§ä¸¥é‡çš„ç¨‹åºè®¾è®¡**é”™è¯¯**
        - `at()`å’Œ *ä¸‹æ ‡* æ“ä½œ**åª**é€‚ç”¨äº`std::string`ï¼Œ`std::vector`ï¼Œ`std::deque`ä»¥åŠ`std::array`
        - `back()`**ä¸**é€‚ç”¨äº`std::foward_list`
- åˆ é™¤å…ƒç´ 
    - `c.pop_back()`ï¼šåˆ é™¤`c`çš„å°¾å…ƒç´ ã€‚è‹¥`c`ä¸ºç©ºï¼Œåˆ™å‡½æ•°è¡Œä¸º *æœªå®šä¹‰* ã€‚è¿”å›`void`
    - `c.pop_front()`ï¼šåˆ é™¤`c`çš„é¦–å…ƒç´ ã€‚è‹¥`c`ä¸ºç©ºï¼Œåˆ™å‡½æ•°è¡Œä¸º *æœªå®šä¹‰* ã€‚è¿”å›`void`
    - `c.erase(p)`ï¼šåˆ é™¤è¿­ä»£å™¨`p`æŒ‡å®šçš„å…ƒç´ ï¼Œè¿”å›æŒ‡å‘è¢«åˆ é™¤å…ƒç´ ä¹‹åå…ƒç´ çš„è¿­ä»£å™¨ã€‚è‹¥`p`æŒ‡å‘å°¾å…ƒç´ ï¼Œåˆ™è¿”å›å°¾åè¿­ä»£å™¨ã€‚è‹¥`p`æ˜¯å°¾åè¿­ä»£å™¨ï¼Œå‡½æ•°è¡Œä¸º *æœªå®šä¹‰* 
    - `c.erase(b, e)`ï¼šåˆ é™¤è¿­ä»£å™¨`b`å’Œ`e`æ‰€æŒ‡å®šèŒƒå›´å†…çš„å…ƒç´ ï¼Œè¿”å›æŒ‡å‘æœ€åä¸€ä¸ªè¢«åˆ é™¤å…ƒç´ ä¹‹åå…ƒç´ çš„è¿­ä»£å™¨ã€‚è‹¥`e`æœ¬èº«å°±æ˜¯å°¾åè¿­ä»£å™¨ï¼Œä¹Ÿè¿”å›å°¾åè¿­ä»£å™¨
    - `c.clear()`ï¼šåˆ é™¤`c`ä¸­æ‰€æœ‰å…ƒç´ ã€‚ç­‰ä»·äº`c.erase(c.begin(), c.end())`ã€‚è¿”å›`void`
    - æ³¨æ„äº‹é¡¹
        - åˆ é™¤`std::deque`ä¸­ *é™¤é¦–å°¾ä¹‹å¤–* çš„ä»»ä½•å…ƒç´ éƒ½ä¼šä½¿ *æ‰€æœ‰* æŒ‡å‘è¯¥å®¹å™¨çš„ *è¿­ä»£å™¨* ã€ *å¼•ç”¨* å’Œ *æŒ‡é’ˆ* **å¤±æ•ˆ**
        - åˆ é™¤`std::vector`æˆ–`std::string`ä¸­çš„ä»»ä½•å…ƒç´ éƒ½ä¼šä½¿ *æŒ‡å‘åˆ é™¤ç‚¹ä¹‹å* çš„ *è¿­ä»£å™¨* ã€ *å¼•ç”¨* å’Œ *æŒ‡é’ˆ* **å¤±æ•ˆ**
        - ä¸Šè¿°å‡½æ•° *å¹¶ä¸æ£€æŸ¥å‚æ•°* ã€‚å¿…é¡»ç¡®ä¿è¢«åˆ é™¤**å…ƒç´ çœŸå®å­˜åœ¨**
        - `std::forward_list`æœ‰è‡ªå·±ä¸“å±ç‰ˆæœ¬çš„`erase`ï¼Œ**ä¸æ”¯æŒ**`pop_back`
        - `std::vector`**ä¸æ”¯æŒ**`pop_front`
        - `std::string`**ä¸æ”¯æŒ**`pop_front`
        - `std::array`**ä¸æ”¯æŒ**ä»¥ä¸Šå…¨éƒ¨
    ```
    list<int> lst = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    auto it = lst.begin();
    
    while (it != lst.end())
    {
        if (*it % 2)                        // if the element is odd
        {
            it = lst.erase(it);             // erase this element
        }  
        else
        {
            ++it;
        }  
    }
    ```
- `std::foward_list`çš„ç‰¹æ®Šæ“ä½œ
    - `lst.before_begin()`ï¼Œ`lst.cbefore_begin()`ï¼šè¿”å›å¤´å“¨å…µå…ƒç´ çš„è¿­ä»£å™¨å’Œ`const_iterator`ã€‚**ä¸èƒ½**è§£å¼•ç”¨
    - `lst.insert_after(p, t)`ï¼šåœ¨è¿­ä»£å™¨`p` *ä¹‹å* çš„ä½ç½®æ’å…¥`t`ã€‚è¿”å›æŒ‡å‘æœ€åä¸€ä¸ªæ’å…¥å…ƒç´ çš„è¿­ä»£å™¨
    - `lst.insert_after(p, n, t)`ï¼šåœ¨è¿­ä»£å™¨`p` *ä¹‹å* çš„ä½ç½®æ’å…¥`n`ä¸ª`t`ã€‚è¿”å›æŒ‡å‘æœ€åä¸€ä¸ªæ’å…¥å…ƒç´ çš„è¿­ä»£å™¨
    - `lst.insert_after(p, b, e)`ï¼šåœ¨è¿­ä»£å™¨`p` *ä¹‹å* çš„ä½ç½®æ’å…¥è¿­ä»£å™¨`b`å’Œ`e`æ‰€æŒ‡å®šèŒƒå›´ä¹‹é—´çš„å…ƒç´ ã€‚`b`å’Œ`e`**ä¸èƒ½**æŒ‡å‘`lst`å†…ã€‚å¦‚æœèŒƒå›´ä¸ºç©ºï¼Œåˆ™è¿”å›`p`ã€‚å¦‚æœ`p`æ˜¯å°¾åè¿­ä»£å™¨ï¼Œåˆ™å‡½æ•°è¡Œä¸º *æœªå®šä¹‰* 
    - `lst.insert_after(p, {a, b, c...})`ï¼šåœ¨è¿­ä»£å™¨`p` *ä¹‹å* çš„ä½ç½®æ’å…¥åˆ—è¡¨`{a, b, c...}`ä¸­çš„ *å…ƒç´ *
    - `lst.emplace_after(p, args)`ï¼šä½¿ç”¨`args`åœ¨`p`æŒ‡å®šä½ç½® *ä¹‹å* *åˆ›å»º* ä¸€ä¸ªå…ƒç´ ã€‚è¿”å›æŒ‡å‘è¿™ä¸ªæ–°å…ƒç´ çš„è¿­ä»£å™¨ã€‚å¦‚æœ`p`æ˜¯å°¾åè¿­ä»£å™¨ï¼Œåˆ™å‡½æ•°è¡Œä¸º *æœªå®šä¹‰* 
    - `lst.erase_after(p)`ï¼šåˆ é™¤è¿­ä»£å™¨`p`æŒ‡å‘ä½ç½®ä¹‹åçš„ *ä¸€ä¸ª* å…ƒç´ 
    - `lst.erase_after(b, e)`ï¼šåˆ é™¤è¿­ä»£å™¨`b`å’Œ`e`æ‰€æŒ‡å®šèŒƒå›´ä¹‹é—´ï¼ˆä¸åŒ…æ‹¬`e`ï¼‰çš„å…ƒç´ ã€‚è¿”å›æŒ‡å‘è¢«åˆ å…ƒç´ ä¸‹ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ã€‚å¦‚æœ`p`æŒ‡å‘å°¾å…ƒç´ æˆ–è€…æ˜¯ä¸€ä¸ªå°¾åè¿­ä»£å™¨ï¼Œåˆ™å‡½æ•°è¡Œä¸º *æœªå®šä¹‰* 
    ```
    forward_list<int> flst = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    auto prev = flst.before_begin();        // denotes element "off the start" of flst
    auto curr = flst.begin();               // denotes the first element in flst
    
    while (curr != flst.end())              // while there are still elements to process
    { 
        if (*curr % 2)                      // if the element is odd
        {
            curr = flst.erase_after(prev);  // erase it and move curr
        }
        else 
        {
            prev = curr;                    // move the iterators to denote the next
            ++curr;                         // element and one before the next element
        }
    }
    ```
- å†…å­˜ç®¡ç†
    - `c.resize(n)`ï¼šè°ƒæ•´`c`çš„å¤§å°ä¸º`n`ä¸ªå…ƒç´ ï¼Œè‹¥`n < c.size()`ï¼Œåˆ™å¤šå‡ºçš„å…ƒç´ è¢«**ä¸¢å¼ƒ**ã€‚è‹¥å¿…é¡»æ·»åŠ æ–°å…ƒç´ ï¼Œåˆ™æ–°å…ƒç´ è¿›è¡Œ *å€¼åˆå§‹åŒ–* 
    - `c.resize(n, t)`ï¼šè°ƒæ•´`c`çš„å¤§å°ä¸º`n`ä¸ªå…ƒç´ ï¼Œè‹¥`n < c.size()`ï¼Œåˆ™å¤šå‡ºçš„å…ƒç´ è¢«**ä¸¢å¼ƒ**ã€‚è‹¥å¿…é¡»æ·»åŠ æ–°å…ƒç´ ï¼Œåˆ™æ–°å…ƒç´ å€¼åˆå§‹åŒ–ä¸º`t`
    - `c.shrink_to_fit()`ï¼šå°†`capacity()`å‡å°ä¸ºä¸`size()`ç›¸åŒå¤§å°
    - `c.capacity()`ï¼šä¸é‡æ–°åˆ†é…å†…å­˜çš„è¯ï¼Œ`c`æœ€å¤šå¯ä»¥ä¿å­˜å¤šå°‘å…ƒç´ 
    - `c.reserve(n)`ï¼šåˆ†é…è‡³å°‘èƒ½å®¹çº³`n`ä¸ªå…ƒç´ çš„å†…å­˜ç©ºé—´
        - å¹¶ä¸æ”¹å˜å®¹å™¨ä¸­å…ƒç´ çš„æ•°é‡ï¼Œå®ƒä»…å½±å“`std::vector`é¢„å…ˆåˆ†é…å¤šå¤§ç©ºé—´
        - å½“æ‰€éœ€ç©ºé—´è¶…è¿‡å½“å‰å®¹é‡æ—¶ï¼Œæ‰ä¼šæ”¹å˜å®¹é‡
        - å¦‚æœéœ€æ±‚å¤§äºå½“å‰å®¹é‡ï¼Œè‡³å°‘åˆ†é…ä¸éœ€æ±‚ä¸€æ ·å¤§çš„ç©ºé—´ï¼›åä¹‹ï¼Œä»€ä¹ˆä¹Ÿä¸åš
    - æ³¨æ„äº‹é¡¹
        - å¦‚æœ`resize()`ç¼©å°å®¹å™¨ï¼Œåˆ™æŒ‡å‘ *è¢«åˆ é™¤å…ƒç´ * çš„ *è¿­ä»£å™¨* ã€ *å¼•ç”¨* å’Œ *æŒ‡é’ˆ* **å¤±æ•ˆ**
        - å¯¹äº`resize()`å¯¼è‡´å­˜å‚¨ç©ºé—´é‡æ–°åˆ†é…ï¼ˆå¯¹äº`std::vector`ï¼Œ`std::string`ä»¥åŠ`std::deque`ï¼‰ï¼Œåˆ™ *æ‰€æœ‰* æŒ‡å‘æ­¤å®¹å™¨çš„ *è¿­ä»£å™¨* ã€ *å¼•ç”¨* å’Œ *æŒ‡é’ˆ* **éƒ½ä¼šå¤±æ•ˆ**
        - `shrink_to_fit()` *åªé€‚ç”¨äº* `std::vector`ï¼Œ`std::string`å’Œ`std::deque`
        - `capacity()`å’Œ`reserve(n)` *åªé€‚ç”¨äº* `std::vector`å’Œ`std::string`
        - `std::array`**ä¸æ”¯æŒ**ä»¥ä¸Šå…¨éƒ¨

#### `std::string`çš„ç‰¹æ®Šæ“ä½œ

- é¢å¤–æ„é€ æ–¹æ³•
    - `std::string s(cp, n)`ï¼š`s`æ˜¯`cp`æŒ‡å‘çš„å­—ç¬¦æ•°ç»„ä¸­å‰`n`ä¸ªå­—ç¬¦çš„æ‹·è´ï¼Œæ­¤æ•°ç»„åº”è‡³å°‘åŒ…å«`n`ä¸ªå­—ç¬¦ï¼Œä¸”**å¿…é¡»**ä»¥`'\0'`ç»“å°¾
    - `std::string s(s2, pos2)`ï¼š`s`æ˜¯`std::string s2`ä»ä¸‹æ ‡`pos2`å¼€å§‹çš„å­—ç¬¦çš„æ‹·è´ã€‚è‹¥`pos2 > s2.size()`ï¼Œæ„é€ å‡½æ•°è¡Œä¸º *æœªå®šä¹‰* 
    - `std::string s(s2, pos2, len2)`ï¼š`s`æ˜¯`std::string s2`ä»ä¸‹æ ‡`pos2`å¼€å§‹`len2`ä¸ªå­—ç¬¦çš„æ‹·è´ã€‚è‹¥`pos2 > s2.size()`ï¼Œæ„é€ å‡½æ•°è¡Œä¸º *æœªå®šä¹‰* ã€‚ä¸ç®¡`len2`çš„å€¼æ˜¯å¤šå°‘ï¼Œæ„é€ å‡½æ•°è‡³å¤šæ‹·è´`s2.size() - len2`ä¸ªå­—ç¬¦
    ```
    const char *cp = "Hello World!!!";       // null-terminated array
    char noNull[] = {'H', 'i'};              // not null terminated
    std::string s1(cp);                      // copy up to the null in cp; s1 == "Hello World!!!"
    std::string s2(noNull, 2);               // copy two characters from no_null; s2 == "Hi"
    std::string s3(noNull);                  // undefined: noNull not null terminated
    std::string s4(cp + 6, 5);               // copy 5 characters starting at cp[6]; s4 == "World"
    std::string s5(s1, 6, 5);                // copy 5 characters starting at s1[6]; s5 == "World"
    std::string s6(s1, 6);                   // copy from s1 [6] to end of s1; s6 == "World!!!"
    std::string s7(s1, 6, 20);               // ok, copies only to end of s1; s7 == "World!!!"
    std::string s8(s1, 16);                  // throws an out_of_range exception
    ```
- å–å­ä¸²
    - `s.substr(idx, n)`ï¼šè¿”å›ä¸€ä¸ª`std::string`ï¼ŒåŒ…å«`s`ä¸­ä»ä¸‹æ ‡`idx`å¼€å§‹ *æœ€å¤š* `n`ä¸ªå­—ç¬¦çš„æ‹·è´ã€‚`idx`çš„é»˜è®¤å€¼æ˜¯`0`ã€‚`n`çš„é»˜è®¤å€¼æ˜¯`s.size() - idx`ï¼Œå³æ‹·è´ä»`idx`å¼€å§‹çš„å…¨éƒ¨å†…å®¹ã€‚å¦‚æœ`idx > s.size()`ï¼Œåˆ™æŠ›å‡º`out_of_range`å¼‚å¸¸ï¼›å¦‚æœ`idx + n > s.size()`ï¼Œåˆ™`substr()`ä¼šè°ƒæ•´æ•°å€¼ä¸º`s.size()`
    ```
    std::string s("hello world");
    std::string s2 = s.substr(0, 5);         // s2 = hello
    std::string s3 = s.substr(6);            // s3 = world
    std::string s4 = s.substr(6, 11);        // s3 = world
    std::string s5 = s.substr(12);           // RE: out_of_range exception
    ```
- é¢å¤–ä¿®æ”¹æ–¹æ³•
    - `s.insert(idx, args)`ï¼šåœ¨ä¸‹æ ‡`idx` *ä¹‹å‰* æ’å…¥`args`æŒ‡å®šçš„å­—ç¬¦ã€‚è¿”å›ä¸€ä¸ªæŒ‡å‘`s`çš„å¼•ç”¨
    - `s.insert(iter, args)`ï¼šåœ¨è¿­ä»£å™¨`iter`æŒ‡å‘ä½ç½® *ä¹‹å‰* æ’å…¥`args`æŒ‡å®šçš„å­—ç¬¦ã€‚è¿”å›æŒ‡å‘ç¬¬ä¸€ä¸ªå­—ç¬¦çš„è¿­ä»£å™¨
    - `s.erase(idx, len)`ï¼šåˆ é™¤ä»ä¸‹æ ‡`idx`å¼€å§‹çš„`len`ä¸ªå­—ç¬¦ã€‚å¦‚æœ`len`è¢«çœç•¥ï¼Œåˆ™ä¸€è·¯åˆ åˆ°`s`æœ«å°¾ã€‚è¿”å›ä¸€ä¸ªæŒ‡å‘`s`çš„å¼•ç”¨
    - `s.assign(args)`ï¼šå°†`s`ä¸­çš„å­—ç¬¦æ›¿æ¢ä¸º`args`æŒ‡å®šçš„å­—ç¬¦ã€‚è¿”å›ä¸€ä¸ªæŒ‡å‘`s`çš„å¼•ç”¨
    - `s.append(args)`ï¼šå°†`args`è¿½åŠ åˆ°`s`ã€‚è¿”å›ä¸€ä¸ªæŒ‡å‘`s`çš„å¼•ç”¨
    - `s.replace(idx, len, args)`ï¼šæŠŠ`s`ä¸­ä»ä¸‹æ ‡`idx`å¼€å§‹çš„`len`ä¸ªå­—ç¬¦æ›¿æ¢ä¸º`args`æŒ‡å®šçš„å­—ç¬¦ã€‚è¿”å›ä¸€ä¸ªæŒ‡å‘`s`çš„å¼•ç”¨
    - `s.replace(b, e, args)`ï¼šæŠŠ`s`ä¸­è¿­ä»£å™¨`b`å’Œ`e`æŒ‡å®šçš„èŒƒå›´å†…çš„å­—ç¬¦æ›¿æ¢ä¸º`args`æŒ‡å®šçš„å­—ç¬¦ã€‚è¿”å›ä¸€ä¸ªæŒ‡å‘`s`çš„å¼•ç”¨
    - æ³¨æ„äº‹é¡¹
        - `args` *å¯èƒ½å¯ä»¥* æ˜¯ä»¥ä¸‹é€‰é¡¹ä¹‹ä¸€ï¼Œå…·ä½“é‚£ä¸ªå‡½æ•°ä¸èƒ½ç”¨è°è¿˜æ˜¯æŒ‡æœ›`IDE`çš„è¯­æ³•æç¤ºç½¢
            - `str`ï¼š`std::string`ï¼Œä¸èƒ½ä¸`s`ç›¸åŒ 
            - `str, pos, len`ï¼š`str`ä»ä¸‹æ ‡`pos`å¼€å§‹ *æœ€å¤š* `len`ä¸ªå­—ç¬¦çš„æ‹·è´
            - `cp`ï¼šæŒ‡å‘ä»¥`'\0'`ç»“å°¾çš„å­—ç¬¦æ•°ç»„
            - `cp, len`ï¼š`cp`çš„ *æœ€å¤š* å‰`len`ä¸ªå­—ç¬¦
            - `n, c`ï¼š`n`ä¸ªå­—ç¬¦`c`
            - `b, e`ï¼šè¿­ä»£å™¨`b`å’Œ`e`æŒ‡å®šçš„èŒƒå›´å†…çš„å­—ç¬¦
            - `{'a', 'b', 'c'...}`ï¼šå­—ç¬¦ç»„æˆçš„åˆå§‹åŒ–åˆ—è¡¨
- å­—ç¬¦ä¸²æœç´¢
    - `s.find(args)`ï¼šæŸ¥æ‰¾`args`ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
    - `s.rfind(args)`ï¼šæŸ¥æ‰¾`args`æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®
    - `s.find_first_of(args)`ï¼šæŸ¥æ‰¾`args`ä¸­ *ä»»ä½•ä¸€ä¸ªå­—ç¬¦* ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
    - `s.find_last_of(args)`ï¼šæŸ¥æ‰¾`args`ä¸­ *ä»»ä½•ä¸€ä¸ªå­—ç¬¦* æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®
    - `s.find_first_not_of(args)`ï¼šæŸ¥æ‰¾ç¬¬ä¸€ä¸ª *ä¸åœ¨* `args`ä¸­çš„å­—ç¬¦
    - `s.find_last_not_of(args)`ï¼šæŸ¥æ‰¾æœ€åä¸€ä¸ª *ä¸åœ¨* `args`ä¸­çš„å­—ç¬¦
    - æ³¨æ„äº‹é¡¹
        - `args`**å¿…é¡»**æ˜¯ä»¥ä¸‹å½¢å¼ä¹‹ä¸€
            - `c, pos`ï¼šä»`s`ä¸­ä½ç½®`pos`å¼€å§‹æŸ¥æ‰¾å­—ç¬¦`c`ã€‚`pos`é»˜è®¤å€¼ä¸º`0`
            - `s2, pos`ï¼šä»`s`ä¸­ä½ç½®`pos`å¼€å§‹æŸ¥æ‰¾å­—ç¬¦ä¸²`s2`ã€‚`pos`é»˜è®¤å€¼ä¸º`0`
            - `cp, pos`ï¼šä»`s`ä¸­ä½ç½®`pos`å¼€å§‹æŸ¥æ‰¾å­—ç¬¦æŒ‡é’ˆ`cp`æŒ‡å‘çš„ä»¥`'\0'`ç»“å°¾çš„å­—ç¬¦æ•°ç»„ã€‚`pos`é»˜è®¤å€¼ä¸º`0`
            - `cp, pos, n`ï¼šä»`s`ä¸­ä½ç½®`pos`å¼€å§‹æŸ¥æ‰¾å­—ç¬¦æŒ‡é’ˆ`cp`æŒ‡å‘çš„ä»¥`'\0'`ç»“å°¾çš„å­—ç¬¦æ•°ç»„çš„å‰`n`ä¸ªå­—ç¬¦ã€‚`pos`å’Œ`n`**æ²¡æœ‰é»˜è®¤å€¼**
        - æœç´¢å‡½æ•°è¿”å›å€¼
            - æˆåŠŸï¼Œè¿”å›`std::string::size_type`ï¼ˆ`size_t` aka `unsigned long`ï¼‰ï¼Œè¡¨ç¤ºåŒ¹é…å‘ç”Ÿä½ç½®çš„ *ä¸‹æ ‡* 
            - å¤±è´¥ï¼Œè¿”å›`std::string::npos` *é™æ€æˆå‘˜* ï¼Œç±»å‹ä¹Ÿä¸º`std::string::size_type`ï¼Œåˆå§‹åŒ–ä¸ºå€¼`-1`
    ```
    std::string numbers("0123456789"), name("r2d2");
    std::string::size_type pos = 0;
    
    // each iteration finds the next number in name
    while ((pos = name.find_first_of(numbers, pos)) != std::string::npos) 
    {
        std::cout << "found number at index: " << pos << ", element is " << name[pos] << std::endl;
        ++pos;  // move to the next character
    }
    ```
- å­—ç¬¦ä¸² *å­—å…¸åº* æ¯”è¾ƒ
    - `s.compare(s2)`ï¼šæ¯”è¾ƒ`s`å’Œ`s2`
    - `s.compare(pos1, n1, s2)`ï¼šæ¯”è¾ƒ`s`ä¸­`pos1`å¼€å§‹çš„`n1`ä¸ªå­—ç¬¦å’Œ`s2`
    - `s.compare(pos1, n1, s2, pos2, n2)`ï¼šæ¯”è¾ƒ`s`ä¸­`pos1`å¼€å§‹çš„`n1`ä¸ªå­—ç¬¦å’Œ`s2`ä¸­`pos2`å¼€å§‹çš„`n2`ä¸ªå­—ç¬¦
    - `s.compare(cp)`ï¼šæ¯”è¾ƒ`s`å’Œ`cp`æŒ‡å‘çš„ä»¥`'\0'`ç»“å°¾çš„å­—ç¬¦æ•°ç»„
    - `s.compare(pos1, n1, cp)`ï¼šæ¯”è¾ƒ`s`ä¸­`pos1`å¼€å§‹çš„`n1`ä¸ªå­—ç¬¦å’Œ`cp`æŒ‡å‘çš„ä»¥`'\0'`ç»“å°¾çš„å­—ç¬¦æ•°ç»„
    - `s.compare(pos1, n1, cp, n2)`ï¼šæ¯”è¾ƒ`s`ä¸­`pos1`å¼€å§‹çš„`n1`ä¸ªå­—ç¬¦å’Œ`cp + n2`æŒ‡å‘çš„ä»¥`'\0'`ç»“å°¾çš„å­—ç¬¦æ•°ç»„
- æ•°å€¼è½¬æ¢
    - `std::to_string(val)`
    - `std::stoi(s, p, b)`
    - `std::stol(s, p, b)`
    - `std::stoul(s, p, b)`
    - `std::stoll(s, p, b)`
    - `std::stoull(s, p, b)`
    - `std::stof(s, p)`
    - `std::stod(s, p)`
    - `std::stold(s, p)`
    - æ³¨æ„äº‹é¡¹
        - `s`æ˜¯`std::string`ï¼Œç¬¬ä¸€ä¸ªéç©ºç™½å­—ç¬¦å¿…é¡»æ˜¯ä»¥ä¸‹å†…å®¹ä¹‹ä¸€
            - æ­£è´Ÿå·ï¼ˆ`+`ï¼Œ`-`ï¼‰
            - æ•°å­—ï¼ˆ`[0-9]`ï¼‰
            - åå…­è¿›åˆ¶ç¬¦å·ï¼ˆ`0x`ï¼Œ`0X`ï¼‰
            - å°æ•°ç‚¹ï¼ˆ`.`ï¼‰
        - `s`çš„å…¶ä»–å­—ç¬¦å­—ç¬¦è¿˜å¯ä»¥æœ‰
            - æŒ‡æ•°ç¬¦å·ï¼ˆ`e`ï¼Œ`E`ï¼‰
            - å­—æ¯å­—ç¬¦ï¼ˆå¯¹åº”è¯¥è¿›åˆ¶ä¸­å¤§äº`9`çš„æ•°å­—ï¼‰
        - `p`æ˜¯ *è¾“å‡ºå‚æ•°* ï¼Œç±»å‹ä¸º`size_t *`ï¼Œç”¨æ¥ä¿å­˜`s`ä¸­ç¬¬ä¸€ä¸ªéæ•°å€¼å­—ç¬¦çš„ä¸‹æ ‡ã€‚é»˜è®¤å€¼ä¸º`0`ï¼Œå³ï¼šå‡½æ•°ä¸ä¿å­˜ä¸‹æ ‡
        - `b`ä¸ºåŸºæ•°ï¼Œé»˜è®¤`10`
        - å¦‚æœ`std::string s`å‚æ•°ä¸èƒ½è½¬æ¢æˆæ•°å€¼ï¼Œåˆ™æŠ›å‡º`invalid_argument`å¼‚å¸¸ï¼›å¦‚æœè½¬æ¢å¾—åˆ°çš„æ•°å€¼æº¢å‡ºï¼Œåˆ™æŠ›å‡º`out_of_range`å¼‚å¸¸
    ```
    size_t idx;
    double res = std::stod("+3.14159pi", &idx);
    printf("%lf %zu\n", res, idx);               // 3.141590 8
    ```
    
#### å®¹å™¨é€‚é…å™¨

- é™¤é¡ºåºå®¹å™¨å¤–ï¼Œæ ‡å‡†åº“è¿˜å®šä¹‰äº†ä¸‰ä¸ª *é¡ºåºå®¹å™¨é€‚é…å™¨* ï¼š
    - `std::stack`ï¼ˆä½äºå¤´æ–‡ä»¶`<stack>`ä¸­ï¼‰
        - é»˜è®¤åŸºäº`std::deque`å®ç°
        ```
        // copies elements from deq into stk
        std::stack<int> stk(deq);
        ```
        - ä¹Ÿå¯ä»¥æ¥å—é™¤`std::array`ä»¥åŠ`std::forward_list`ä¹‹å¤–çš„ä»»ä¸€é¡ºåºå®¹å™¨ï¼Œå°è£…æˆä¸€ä¸ªæ ˆ
        ```
        // empty stack implemented on top of vector
        std::stack<std::string, std::vector<std::string>> str_stk;
        // str_stk2 is implemented on top of vector and initially holds a copy of svec
        std::stack<std::string, std::vector<std::string>> str_stk2(svec);
        ```
        - ç‰¹æœ‰æ“ä½œ
            - `s.pop()`ï¼šå¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼Œä½†ä¸è¿”å›è¯¥å…ƒç´ çš„å€¼
            - `s.push(item)`ï¼šå‹æ ˆä¸€ä¸ªå€¼ä¸º`item`çš„å…ƒç´ 
            - `s.emplace(args)`ï¼šå‹æ ˆä¸€ä¸ªç”¨`args` *æ„é€ * çš„å…ƒç´ 
            - `s.top()`ï¼šè¿”å›æ ˆé¡¶å…ƒç´ ï¼Œä½†ä¸å°†å…¶å¼¹å‡º
    - `std::queue`ï¼ˆä½äºå¤´æ–‡ä»¶`<queue>`ä¸­ï¼‰
        - é»˜è®¤åŸºäº`std::deque`å®ç°ï¼Œä¹Ÿå¯ä»¥æ¥å—é™¤`std::array`ã€`std::forward_list`ä»¥åŠ`std::vector`ä¹‹å¤–çš„ä»»ä¸€é¡ºåºå®¹å™¨
        - é»˜è®¤ *å…ˆå…¥å…ˆå‡º* ï¼ˆ`FIFO`ï¼‰ï¼Œé˜Ÿå°¾å…¥é˜Ÿï¼Œé˜Ÿé¦–å‡ºé˜Ÿ
        - ç‰¹æœ‰æ“ä½œ
            - `q.pop()`ï¼šå¼¹å‡ºé¦–å…ƒç´ ï¼Œä½†ä¸è¿”å›è¯¥å…ƒç´ çš„å€¼
            - `q.front()`ï¼šè¿”å›é¦–å…ƒç´ ï¼Œä½†ä¸å°†å…¶å¼¹å‡º
            - `q.back()`ï¼šè¿”å›å°¾å…ƒç´ ï¼Œä½†ä¸å°†å…¶å¼¹å‡º
            - `q.push(item)`ï¼šå…¥é˜Ÿï¼ˆåœ¨é˜Ÿåˆ—æœ«å°¾ï¼‰ä¸€ä¸ªå€¼ä¸º`item`çš„å…ƒç´ 
            - `q.emplace(args)`ï¼šå…¥é˜Ÿï¼ˆåœ¨é˜Ÿåˆ—æœ«å°¾ï¼‰ä¸€ä¸ªç”¨`args` *æ„é€ * çš„å…ƒç´ 
    - `std::priority_queue`ï¼ˆä½äºå¤´æ–‡ä»¶`<queue>`ä¸­ï¼‰
        - é»˜è®¤åŸºäº`std::vector`å®ç°ï¼Œä¹Ÿå¯ä»¥æ¥å—`std::deque`
        - æ ‡å‡†åº“çš„å®ç°å†™æ­»äº†ï¼Œæ˜¯ *å°é¡¶å †* ã€‚å³ï¼šè‹¥`a < b`ï¼Œåˆ™`a`çš„ä¼˜å…ˆçº§æ¯”`b`é«˜ã€‚è‹¥æƒ³åˆ¶é€ å¤§é¡¶å †ï¼Œå¯ä»¥ï¼š
            - é‡è½½`<`è¿ç®—ç¬¦ => 11.2.2
            - æ’å…¥ç›¸åæ•°
        - ç‰¹æœ‰æ“ä½œ
            - `q.pop()`ï¼šå¼¹å‡ºæœ€é«˜ä¼˜å…ˆçº§å…ƒç´ ï¼Œä½†ä¸è¿”å›è¯¥å…ƒç´ çš„å€¼
            - `q.top()`ï¼šè¿”å›æœ€é«˜ä¼˜å…ˆçº§å…ƒç´ ï¼Œä½†ä¸å°†å…¶å¼¹å‡º
            - `q.push(item)`ï¼šï¼ˆåœ¨é€‚å½“ä½ç½®ï¼‰æ’å…¥ä¸€ä¸ªå€¼ä¸º`item`çš„å…ƒç´ 
            - `q.emplace(args)`ï¼šï¼ˆåœ¨é€‚å½“ä½ç½®ï¼‰æ’å…¥ä¸€ä¸ªç”¨`args` *æ„é€ * çš„å…ƒç´ 
- *æ‰€æœ‰* å®¹å™¨é€‚é…å™¨ *éƒ½æ”¯æŒ* çš„æ“ä½œå’Œç±»å‹
    - `size_type`
    - `value_type`
    - `container_type`ï¼šå®ç°æ­¤é€‚é…å™¨çš„åº•å±‚å®¹å™¨çš„ç±»å‹
    - `A a`
    - `A a(c)`
    - *å…³ç³»è¿ç®—ç¬¦* ï¼š`==`ï¼Œ`!=`ï¼Œ`<`ï¼Œ`<=`ï¼Œ`>`ï¼Œ`>=`
    - `a.empty()`
    - `a.size()`
    - `std::swap(a, b)`ï¼Œ`a.swap(b)`
    
### ğŸŒ± [Chap 11] [å…³è”å®¹å™¨](https://en.cppreference.com/w/cpp/container)ï¼ˆAssociative Containerï¼‰

- 

### ğŸŒ± [Chap 10] [æ³›å‹ç®—æ³•](https://en.cppreference.com/w/cpp/algorithm)ï¼ˆGeneric Algorithmsï¼‰

#### åˆè¯†

- ä½ç½®
    - å¤§éƒ¨åˆ†æ³›å‹ç®—æ³•å®šä¹‰äºå¤´æ–‡ä»¶`<algorithm>`ä¸­
    - æ ‡å‡†åº“è¿˜åœ¨å¤´æ–‡ä»¶`<numeric>`ä¸­å®šä¹‰äº†ä¸€ç»„æ•°å€¼æ³›å‹ç®—æ³•
- åŸåˆ™
    - æ³›å‹ç®—æ³•æ°¸è¿œ**ä¸ä¼š**ç›´æ¥æ“ä½œå®¹å™¨ï¼Œä½†ä»æ—§ä¾èµ–äºå…ƒç´ ç±»å‹çš„æ“ä½œ
        - æ³›å‹ç®—æ³•åªä¼šè¿è¡Œäº *è¿­ä»£å™¨* ä¹‹ä¸Šï¼Œä¸ä¼šæ‰§è¡Œç‰¹å®šå®¹å™¨çš„æ“ä½œï¼Œç”šè‡³ä¸éœ€åœ¨æ„è‡ªå·±éå†çš„æ˜¯ä¸æ˜¯å®¹å™¨
            - å› æ­¤ï¼Œ**æ³›å‹ç®—æ³•ä¸èƒ½ï¼ˆç›´æ¥ï¼‰æ·»åŠ æˆ–åˆ é™¤å…ƒç´ **
        - è°ƒç”¨æ³›å‹ç®—æ³•æ—¶ï¼Œåœ¨ä¸éœ€è¦ä½¿ç”¨è¿”å›çš„è¿­ä»£å™¨ä¿®æ”¹å®¹å™¨çš„æƒ…å†µä¸‹ï¼Œä¼ å‚åº”ä¸º`const_iterator`
    - å¤§å¤šæ•°ç®—æ³•æä¾›æ¥å£ï¼Œå…è®¸æˆ‘ä»¬ç”¨ *è°“è¯* ï¼ˆpredicateï¼‰ä»£æ›¿é»˜è®¤çš„è¿ç®—ç¬¦
        - è°“è¯æ˜¯å¯è°ƒç”¨çš„è¡¨è¾¾å¼ã€‚å…·ä½“ä¼ å‚å¯ä»¥ç”¨
            - å‡½æ•°å¤´
            - å‡½æ•°æŒ‡é’ˆ
            - å‡½æ•°å¯¹è±¡ï¼ˆé‡è½½äº†è°ƒç”¨è¿ç®—ç¬¦çš„ç±»çš„å®ä¾‹ï¼‰ => 14.8
            - `lambda`è¡¨è¾¾å¼ => 10.3.2
        - æ ‡å‡†åº“ç®—æ³•ä½¿ç”¨ä»¥ä¸‹ä¸¤ç±»è°“è¯
            - *ä¸€å…ƒè°“è¯* ï¼ˆunary predicateï¼‰
                - æ¥å—å•ä¸€å‚æ•°
                - ä¸€èˆ¬ä¸ºè¿­ä»£å™¨æŒ‡å‘å…ƒç´ ç±»å‹çš„å¸¸å¼•ç”¨
                    - ä¸æ˜¯å¼ºåˆ¶è¦æ±‚ï¼Œä½†æ³›å‹ç®—æ³•éƒ½è¦æ±‚è°“è¯**ä¸èƒ½**æ”¹å˜ä¼ å…¥å…ƒç´ çš„å€¼
            - *äºŒå…ƒè°“è¯* ï¼ˆbinary predicateï¼‰
                - æ¥å—ä¸¤ä¸ªå‚æ•°
                - ä¸€èˆ¬å‡ä¸ºè¿­ä»£å™¨æŒ‡å‘å…ƒç´ ç±»å‹çš„å¸¸å¼•ç”¨
                    - ä¸æ˜¯å¼ºåˆ¶è¦æ±‚ï¼Œä½†æ³›å‹ç®—æ³•éƒ½è¦æ±‚è°“è¯**ä¸èƒ½**æ”¹å˜ä¼ å…¥å…ƒç´ çš„å€¼
- å…¬è®¤å‡è®¾
    - é‚£äº›åªæ¥å—ä¸€ä¸ªå•ä¸€è¿­ä»£å™¨æ¥è¡¨ç¤ºç¬¬äºŒä¸ªåºåˆ—çš„ç®—æ³•ï¼Œéƒ½å‡å®šç¬¬äºŒä¸ªåºåˆ—è‡³å°‘ä¸ç¬¬ä¸€ä¸ªåºåˆ—ä¸€æ ·é•¿
    - å‘ç›®çš„ä½ç½®è¿­ä»£å™¨å†™æ•°æ®çš„ç®—æ³•éƒ½å‡å®šç›®çš„ä½ç½®è¶³å¤Ÿå¤§ï¼Œèƒ½å®¹çº³è¦å†™å…¥çš„å…ƒç´ 
- åªè¯»ç®—æ³• *ä¸¾ä¾‹*
    - [`std::find()`](https://en.cppreference.com/w/cpp/algorithm/find)
        - åŸå‹
        ```
        template <class InputIt, class T>
        InputIt 
        find(InputIt   first, 
             InputIt   last, 
             const T & value);
             
        template <class InputIt, class UnaryPredicate>
        InputIt 
        find_if(InputIt        first, 
                InputIt        last,
                UnaryPredicate p);
                
        template <class InputIt, class UnaryPredicate>
        InputIt 
        find_if_not(InputIt        first, 
                    InputIt        last,
                    UnaryPredicate q);
        ```
        - è¿”å›
            - `find`ï¼šç¬¬ä¸€ä¸ªåœ¨åŒºé—´`[first, last)`ä¹‹å†…çš„å€¼ä¸º`value`çš„è¿­ä»£å™¨ï¼Œå¦‚ä¸å­˜åœ¨åˆ™è¿”å›`last`
            - `find`ï¼šå€¼æ»¡è¶³`p(*iter) == true`
            - `find_if_not`ï¼šå€¼æ»¡è¶³`q(*iter) == false`
        ```
        std::vector<int> vec{0, 1, 2, 3, 4, 5, 6...};
        int val = 3;
        std::vector<int>::const_iterator res = std::find(vec.cbegin(), vec.cend(), val);
        std::cout << "The value " << val << (res == vec.cend()) ? " is NOT present" ï¼š â€œ is presentâ€ << std::endl;
        ```
        - æŒ‡é’ˆå°±æ˜¯ä¸€ç§è¿­ä»£å™¨ï¼Œå› æ­¤`std::find()`å¯ç”¨äºå†…ç½®æ•°ç»„
        ```
        int arr[]{0, 1, 2, 3, 4, 5, 6...};
        int val = 3;
        int * res_1 = std::find(std::begin(arr), std::end(arr), val);
        int * res_2 = std::find(arr + 1, arr + 4, val);
        ```
    - [`std::count()`](https://en.cppreference.com/w/cpp/algorithm/count)
        - åŸå‹
        ```
        template <class InputIt, class T>
        typename iterator_traits<InputIt>::difference_type
        count(InputIt   first, 
              InputIt   last, 
              const T & value);
              
        template <class InputIt, class UnaryPredicate>
        typename iterator_traits<InputIt>::difference_type
        count_if(InputIt first, 
                 InputIt last, 
                 UnaryPredicate p);
        ```
        - è¿”å›ï¼š`ptrdiff_t` aka `long int`ï¼ŒåŒºé—´`[first, last)`ä¹‹å†…ç­‰äº`value`æˆ–è€…æ»¡è¶³`p(*iter) == true`çš„å€¼çš„ä¸ªæ•°
    - [`std::accumulate()`](https://en.cppreference.com/w/cpp/algorithm/accumulate)
        - åŸå‹
        ```
        template <class InputIt, class T, class BinaryOperation>
        T 
        accumulate(InputIt         first, 
                   InputIt         last, 
                   T               init,
                   BinaryOperation op);
        ```
        - è¿”å›ï¼šåŒºé—´`[first, last)`ä¹‹å†…æ‰€æœ‰å…ƒç´ ä»¥åŠ`init`çš„ *åŸºäº* `op` çš„ *æ€»å’Œ* 
            - å®é™…æ“ä½œ *ç¤ºä¾‹* 
            ```
            for (; first != last; ++first)
            {
                init = binary_op(init, *first);
            }
            
            return init;
            ```
    - [`std::equal()`](https://en.cppreference.com/w/cpp/algorithm/equal)
        - åŸå‹
        ```
        template <class InputIt1, class InputIt2>
        bool 
        equal(InputIt1 first1, 
              InputIt1 last1,
              InputIt2 first2);
        
        template <class InputIt1, class InputIt2, class BinaryPredicate>
        bool 
        equal(InputIt1        first1, 
              InputIt1        last1,
              InputIt2        first2, 
              BinaryPredicate p);
            
        template <class InputIt1, class InputIt2>
        bool 
        equal(InputIt1 first1, 
              InputIt1 last1,
              InputIt2 first2, 
              InputIt2 last2);
            
        template <class InputIt1, class InputIt2, class BinaryPredicate>
        bool 
        equal(InputIt1        first1, 
              InputIt1        last1,
              InputIt2        first2, 
              InputIt2        last2,
              BinaryPredicate p);
        ```
        - è¿”å›ï¼šå¦‚æœ *åºåˆ—1* ä¸­æ‰€æœ‰å…ƒç´ éƒ½ä¸ *åºåˆ—2* ä¸­å¯¹åº”ä½ç½®å…ƒç´ æ»¡è¶³`*iter1 == *iter2`æˆ–`p(*iter1, *iter2) == true`ï¼Œåˆ™è¿”å›`true`ï¼Œåä¹‹è¿”å›`false`
- å†™ç®—æ³• *ä¸¾ä¾‹*
    - [`std::fill()`](https://en.cppreference.com/w/cpp/algorithm/fill)
        - åŸå‹
        ```
        template <class ForwardIt, class T>
        void 
        fill(ForwardIt first, 
             ForwardIt last, 
             const T & value);
        ```
        - å°†åŒºé—´`[first, last)`ä¹‹å†…æ‰€æœ‰å…ƒç´ éƒ½èµ‹å€¼ä¸º`value` 
        ```
        std::fill(vec.begin(), vec.end(), 0));
        std::fill(vec.begin(), vec.begin() + vec.size() / 2, 0));
        ```
    - [`std::fill_n()`](https://en.cppreference.com/w/cpp/algorithm/fill_n)
        - åŸå‹
        ```
        template <class OutputIt, class Size, class T>
        OutputIt 
        fill_n(OutputIt  first, 
               Size      count, 
               const T & value);
        ```
        - å°†åŒºé—´`[first, first + count)`ä¹‹å†…æ‰€æœ‰å…ƒç´ éƒ½èµ‹å€¼ä¸º`value` 
            - `std::fill_n()`**ä¸**æ£€æŸ¥å†™åŒºé—´`[first, first + count)`æ˜¯å¦åˆæ³•ï¼Œè¿™æ˜¯ç¨‹åºå‘˜çš„è´£ä»»
            - åœ¨ *ç©ºå®¹å™¨* ä¸Šè°ƒç”¨`std::fill_n()`æˆ–å…¶å®ƒå†™ç®—æ³•æ˜¯**æœªå®šä¹‰è¡Œä¸º**
        - è¿”å›ï¼šè¿­ä»£å™¨`first + count`
- å¹¶è¡Œç®—æ³• *ä¸¾ä¾‹*
    - [`std::for_each()`](https://en.cppreference.com/w/cpp/algorithm/for_each)
        - åŸå‹
        ```
        template <class InputIt, class UnaryFunction>
        UnaryFunction 
        for_each(InputIt first, 
                 InputIt last, 
                 UnaryFunction f);
        ```
        - ä¾æ¬¡å¯¹åŒºé—´`[first, last)`å†…æ¯ä¸ªå…ƒç´ è°ƒç”¨`f(*iter)`
            - å¦‚æœ`InputIt`ä¸æ˜¯å¸¸è¿­ä»£å™¨ï¼Œåˆ™`f`å¯ä»¥ä¿®æ”¹å…ƒç´ ã€‚
            - `f`å¦‚æœ‰è¿”å›å€¼ï¼Œåˆ™ç›´æ¥è¢«ä¸¢å¼ƒ
            - **ä¸èƒ½**å¤åˆ¶åºåˆ—ä¸­çš„å…ƒç´ 
        - è¿”å›ï¼šå½¢å‚`f`çš„æ‹·è´ï¼Œç»è¿‡è¿­ä»£ä¹‹åè¿”å›ä¹‹
            - `f`ä¸æ˜¯å¼•ç”¨ç±»å‹ï¼Œå› æ­¤ä¼ å…¥çš„`f`**ä¸ä¼š**è¢«ä¿®æ”¹
            - æƒ³è¦è·å¾—ç»å†è¿‡è¿­ä»£çš„`f`ï¼Œåˆ™ *åªèƒ½ä¾é è¿”å›å€¼* ã€‚ä¾‹å¦‚ä¸‹é¢ä»£ç 
        ```
        struct Sum
        {
            void operator()(int n) { sum += n; }
            int sum{0};
        };
         
        std::vector<int> nums{3, 4, 2, 8, 15, 267};
        std::for_each(nums.begin(), nums.end(), [](int &n){ n++; });  // nums chamges to: 4 5 3 9 16 268
        Sum tmp;
        Sum sum = std::for_each(nums.begin(), nums.end(), tmp);       // tmp.sum == 0 !!!
                                                                      // sum.sum == 305
        ```
- æ‹·è´ç®—æ³• *ä¸¾ä¾‹*
    - [`std::copy()`](https://en.cppreference.com/w/cpp/algorithm/copy)
        - åŸå‹
        ```
        template <class InputIt, class OutputIt>
        OutputIt 
        copy(InputIt  first, 
             InputIt  last, 
             OutputIt d_first);
             
        template <class InputIt, class OutputIt, class UnaryPredicate>
        OutputIt 
        copy_if(InputIt first, 
                InputIt last,
                OutputIt d_first,
                UnaryPredicate pred);
        ```
        - å°†åŒºé—´`[first, last)`ä¹‹å†…æ‰€æœ‰å…ƒç´ æ‹·è´è‡³ä»¥`d_first`å¼€å§‹çš„ä¸€ç‰‡å†…å­˜ä¸­ï¼Œ
            - `copy_if`ï¼šåªæ‹·è´æ»¡è¶³`pred(*iter) == true`çš„å…ƒç´ 
            - éœ€ä¿è¯å†™`d_first`å¼€å§‹çš„è¿™ä¸€ç‰‡å†…å­˜æ˜¯åˆæ³•è¡Œä¸º
        - è¿”å›ï¼šæ‹·è´ç”Ÿæˆçš„åºåˆ—çš„å°¾åè¿­ä»£å™¨
        ```
        int a1[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; 
        int a2[sizeof(a1) / sizeof(*a1)]; 
        int * res = std::copy(std::begin(a1), std::end(a1), a2); 
        ```
    - [`std::replace()`](https://en.cppreference.com/w/cpp/algorithm/replace)
        - åŸå‹
        ```
        template <class ForwardIt, class T>
        void 
        replace(ForwardIt first, 
                ForwardIt last,
                const T & old_value, 
                const T & new_value);
              
        template <class ForwardIt, class UnaryPredicate, class T>
        void 
        replace_if(ForwardIt      first, 
                   ForwardIt      last,
                   UnaryPredicate p, 
                   const T &      new_value);
        ```
        - å°†åŒºé—´`[first, last)`ä¹‹å†…æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„å…ƒç´ ä¿®æ”¹ä¸º`new_value`
            - `replace`ï¼šå€¼ä¸º`old_value`çš„å…ƒç´ 
            - `replace_if`ï¼šæ»¡è¶³`p(*iter) == true`çš„å…ƒç´ 
        - è¿”å›ï¼šæ‹·è´ç”Ÿæˆçš„åºåˆ—çš„å°¾åè¿­ä»£å™¨
        ```
        std::replace(lst.begin(), lst.end(), 0, 42);
        ```
    - [`std::replace_copy()`](https://en.cppreference.com/w/cpp/algorithm/replace_copy)
        - åŸå‹
        ```
        template <class InputIt, class OutputIt, class T>
        OutputIt 
        replace_copy(InputIt   first, 
                     InputIt   last, 
                     OutputIt  d_first,
                     const T & old_value, 
                     const T & new_value);
                       
        template <class InputIt, class OutputIt, class UnaryPredicate, class T>
        OutputIt 
        replace_copy_if(InputIt        first, 
                        InputIt        last, 
                        OutputIt       d_first,
                        UnaryPredicate p, 
                        const T &      new_value);
        ```
        - å°†å¯¹åº” *æ›¿æ¢è§„åˆ™* åº”ç”¨äºåŒºé—´`[first, last)`å†…ï¼Œå¹¶å°†ç»“æœå­˜å‚¨äº`d_first`å¼€å§‹çš„ä¸€ç‰‡åŒºåŸŸä¸­
            - `replace_copy`ï¼šå…¶ä¸­æ‰€æœ‰å€¼ä¸º`old_value`å…ƒç´ éƒ½è¢«ä¿®æ”¹ä¸º`new_value`
            - `replace_copy_if`ï¼šåªæ›¿æ¢æ»¡è¶³`p(*iter) == true`çš„å…ƒç´ 
        - è¿”å›ï¼šæ‹·è´ç”Ÿæˆçš„åºåˆ—çš„å°¾åè¿­ä»£å™¨
        ```
        // æ­¤è°ƒç”¨åï¼Œilstä¸å˜ï¼ŒivecåŒ…å«ilstçš„ä¸€ä»½æ‹·è´ï¼Œä¸”åŸæ¥çš„0å…¨éƒ¨è¢«æ›¿æ¢ä¸º42
        std::replace_copy(ilst.begin(), ilst.end(), std::back_inserter(ivec), 0, 42);
        ```
    - [`std::transform()`](https://en.cppreference.com/w/cpp/algorithm/transform)
        - åŸå‹
        ```
        template <class InputIt, class OutputIt, class UnaryOperation>
        OutputIt 
        transform(InputIt first1, 
                  InputIt last1, 
                  OutputIt d_first,
                  UnaryOperation unary_op);
        
        template <class InputIt1, class InputIt2, class OutputIt, class BinaryOperation>
        OutputIt 
        transform(InputIt1 first1, 
                  InputIt1 last1, 
                  InputIt2 first2,
                  OutputIt d_first, 
                  BinaryOperation binary_op);
        ```
        - å°† *å¯¹åº”å‡½æ•°* åº”ç”¨äº *ä¸€ç‰‡åŒºé—´* å†…ï¼Œå¹¶å°†ç»“æœå­˜å‚¨äº`d_first`å¼€å§‹çš„ä¸€ç‰‡åŒºåŸŸä¸­
            1. å°†`unary_op`åº”ç”¨äº`[first, last)`ä¸Šçš„æ¯ä¸ªå…ƒç´ ï¼Œå–å…¶è¿”å›å€¼
            2. å°†`binary_op`åº”ç”¨å¦‚ä¸‹å®šä¹‰çš„ä¸€å¯¹å…ƒç´ ä¸Šï¼šä¸€ä¸ªå®šä¹‰åœ¨`[first, last)`ä¸Šï¼Œå¦ä¸€ä¸ªå–è‡ªä»`first2`å¼€å§‹çš„å¯¹åº”ä½ç½®ï¼Œå–å…¶è¿”å›å€¼
        - è¾“å‡ºå¯¹è±¡å¯ä»¥æ˜¯ *è‡ªå·±* 
        - è¿”å›ï¼šæ‹·è´ç”Ÿæˆçš„åºåˆ—çš„å°¾åè¿­ä»£å™¨
        ```
        // turn all elements of a int vector into their absolute values
        std::transform(vec.begin(), vec.end(), vec.begin(), [] (const int & i)
        {
            return i < 0 ? -i : i;
        });
        ```
- æ’åºç®—æ³• *ä¸¾ä¾‹*
    - [`std::sort()`](https://en.cppreference.com/w/cpp/algorithm/sort)
        - åŸå‹
        ```
        template <class RandomIt>
        void 
        sort(RandomIt first, 
             RandomIt last);
        
        template <class RandomIt, class Compare>
        void 
        sort(RandomIt first, 
             RandomIt last, 
             Compare  comp);
        ```
        - æŠŠåŒºé—´`[first, last)`å†…å…ƒç´ æŒ‰ç…§ *éé™åº* ï¼ˆnon-descending orderï¼‰æ’åº
            - **ä¸æ˜¯**ç¨³å®šæ’åº
            - é‡æ’ä¸¤ä¸ªå…ƒç´ çš„æ¡ä»¶ï¼š`*(it + n) < *it`æˆ–`comp(*(it + n), *it) == true`ï¼ˆ`n > 0`ï¼‰
        - å¤æ‚åº¦
            - `O(NÂ·log(N))`, where `N = std::distance(first, last)` comparisons *on average* `(until C++11)`
            - `O(NÂ·log(N))`, where `N = std::distance(first, last)` comparisons `(since C++11)`
    - [`std::unique()`](https://en.cppreference.com/w/cpp/algorithm/unique)
        - åŸå‹
        ```
        template <class ForwardIt>
        ForwardIt 
        unique(ForwardIt first, 
               ForwardIt last);

        template <class ForwardIt, class BinaryPredicate>
        ForwardIt
        unique(ForwardIt       first, 
               ForwardIt       last, 
               BinaryPredicate p);
        ```
        - å¯¹åŒºé—´`[first, last)`ä¸­æ¯ä¸€ç»„ *è¿ç»­çš„* *ç›¸ç­‰* å…ƒç´ ï¼Œåªä¿ç•™ç¬¬ä¸€ä¸ªï¼Œ *æ¸…é™¤* å…¶ä½™å…ƒç´ 
            - *æ¸…é™¤* ï¼šç”¨è¢«æ¸…é™¤å…ƒç´ åé¢çš„å…ƒç´ è¦†ç›–è¢«æ¸…é™¤å…ƒç´ ï¼Œ**å¹¶ä¸**æ”¹å˜å®¹å™¨å¤§å°
            - *ç›¸ç­‰* ï¼š`*iter1 == *iter2`æˆ–`p(*iter1, *iter2) == true`
        - è¿”å›ï¼šæ¸…é™¤å®Œæˆåçš„é€»è¾‘åŒºé—´çš„å°¾åè¿­ä»£å™¨ï¼ˆpast-the-end iterator for the new logical end of the rangeï¼‰
            - æ­¤è¿­ä»£å™¨åé¢çš„å…ƒç´ ä»å¯è¢«è§£å¼•ç”¨è®¿é—®ï¼Œä½†å€¼ *æœªå®šä¹‰*
        - ä½¿ç”¨å‰åº”è¯¥**å…ˆè°ƒç”¨**`std::sort()`ï¼Œä¹‹å**å†è°ƒç”¨**å®¹å™¨çš„`erase()`æ–¹æ³•
            - *æ ‡å‡†åº“ç®—æ³•* æ“ä½œçš„ *å‡æ˜¯* è¿­ä»£å™¨è€Œä¸æ˜¯å®¹å™¨ï¼Œå› æ­¤ï¼Œ**æ ‡å‡†åº“ç®—æ³•ä¸èƒ½ï¼ˆç›´æ¥ï¼‰æ·»åŠ æˆ–åˆ é™¤å…ƒç´ **
        ```
        void eliminateDuplicates(std::vector<int> & vec)
        {
            std::sort(vec.begin(), vec.end());
            std::vector<int>::iterator dup_begin = std::unique(vec.begin(), vec.end());
            vec.erase(dup_begin, vec.end());
        }
        ```   
   
#### [`lambda`è¡¨è¾¾å¼](https://en.cppreference.com/w/cpp/language/lambda)

- å¯ä»¥ç†è§£ä¸ºæœªå‘½åçš„`inline`å‡½æ•°
    - å‘å‡½æ•°ä¼ é€’`lambda`æ—¶ï¼Œ`lambda`ä¼š *ç«‹å³æ‰§è¡Œ*
    - ç¼–è¯‘å™¨å®ç°ï¼šå½“å®šä¹‰`lambda`æ—¶
        - ç¼–è¯‘å™¨ç”Ÿæˆä¸€ä¸ªä¸æ­¤`lambda`å¯¹åº”çš„æ–°çš„æœªå‘½åç±»ç±»å‹ï¼Œä¸ä¸€ä¸ªè¯¥ç±»å‹çš„æœªå‘½åå®ä¾‹ï¼ˆå‡½æ•°å¯¹è±¡ï¼‰ => 14.8.1
        - åŒ¿å`lambda`ç”¨äºä¼ å‚æ—¶ï¼Œä¼ é€’çš„å°±æ˜¯ç°ç”Ÿæˆçš„è¯¥ç±»çš„ä¸€ä¸ªä¸´æ—¶å®ä¾‹ï¼ˆçš„æ‹·è´ï¼‰
        - ç”¨`auto`å®šä¹‰ä¸€ä¸ªç”¨`lambda`åˆå§‹åŒ–çš„å˜é‡æ—¶ï¼Œåˆ™å®šä¹‰äº†ä¸€ä¸ªä»`lambda`ç”Ÿæˆçš„è¯¥ç±»å‹å¯¹è±¡å®ä¾‹
        - é»˜è®¤æƒ…å†µä¸‹ï¼Œä»`lambda`ç”Ÿæˆçš„ç±»éƒ½åŒ…å« *å¯¹åº”æ‰€æ•è·å˜é‡* çš„ *æ•°æ®æˆå‘˜* 
        - `lambda`çš„æ•°æ®æˆå‘˜å’Œæ™®é€šçš„ç±»ä¸€æ ·ï¼Œä¹Ÿåœ¨å¯¹è±¡è¢«åˆ›å»ºæ—¶åˆå§‹åŒ–
- å®šä¹‰æ ¼å¼
```
auto f = [capture_list] (paramater_list) -> return_type { function_body; };
```
- å†…å®¹ç‰©
    - æ•è·åˆ—è¡¨
        - æŠŠ`lambda`è¡¨è¾¾å¼ *æ‰€åœ¨çš„å‡½æ•°ä¸­çš„å±€éƒ¨éé™æ€å˜é‡* å£°æ˜åœ¨æ•è·åˆ—è¡¨é‡Œï¼Œå°±å¯ä»¥åœ¨`lambda`è¡¨è¾¾å¼å‡½æ•°ä½“ä½¿ç”¨è¯¥å˜é‡
        - å¯¹äºå±€éƒ¨é™æ€å˜é‡æˆ–è€…å…¨å±€å˜é‡ï¼Œåˆ™**ä¸éœ€æ•è·**å³å¯ä½¿ç”¨
        - æ•è·æ–¹å¼ï¼šä¸å‚æ•°ä¼ é€’æ–¹å¼ç±»ä¼¼ï¼Œå¯ä»¥æ˜¯
            - *å€¼æ•è·* ï¼šæ•è·è¢«åˆ›å»ºæ—¶å˜é‡çš„ *æ‹·è´* 
                - *å¯å˜ `lambda`*
                    - ä¸åŠ `mutable`å‚æ•°ï¼Œåˆ™æ•è·çš„å˜é‡è¢«è®¾ç½®ä¸º *åªè¯»å¸¸é‡*
                    - å¦‚æœä½¿ç”¨äº†`mutable`å‚æ•°ï¼Œåˆ™**ä¸èƒ½**çœç•¥å‚æ•°åˆ—è¡¨
                ```
                size_t v1 = 42;
                auto f1 = [v1]            { return ++v1; };  // error: increment of read-only variable â€˜v1â€™
                auto f2 = [v1] mutable    { return ++v1; };  // error: lambda requires '()' before 'mutable'
                auto f3 = [v1] () mutable { return ++v1; };  // ok
                ```
                - **ä¸èƒ½**æ‹·è´`std::ostream`å¯¹è±¡ï¼Œå› æ­¤æ•è·å®ƒä»¬åªèƒ½é å¼•ç”¨
            - *å¼•ç”¨æ•è·* ï¼šæ•è·è¢«åˆ›å»ºæ—¶å˜é‡çš„ *å¼•ç”¨* 
                - è‡ªç„¶ï¼Œ`lambda`ä¸­ä½¿ç”¨çš„å°±æ˜¯è¢«æ•è·çš„å¯¹è±¡æœ¬èº«ï¼Œåœ°å€æ˜¯ä¸€æ ·çš„
                - è¢«å¼•ç”¨æ•è·çš„å˜é‡èƒ½å¦ *ä¿®æ”¹* å–å†³äºé‚£ä¸ªå˜é‡åŸå…ˆ *æ˜¯ä¸æ˜¯å¸¸é‡* 
                    - å¦‚æœæ˜¯**å¸¸é‡**ï¼Œé‚£ä¹ˆæ•è·çš„å¼•ç”¨å°±æ˜¯å¸¸å¼•ç”¨ï¼Œè‡ªç„¶**ä¸èƒ½æ”¹**
                - å¼•ç”¨æ•è·ä¸è¿”å›æ•è·æœ‰ç›¸åŒçš„é™åˆ¶ï¼Œå³ï¼šå¿…é¡»ç¡®ä¿`lambda`è¢«è°ƒç”¨æ—¶è¢«å¼•ç”¨çš„å¯¹è±¡ä¾ç„¶ *å­˜åœ¨* 
                    - å¦‚æœ`lambda`åœ¨å‡½æ•°ç»“æŸåè¢«è°ƒç”¨ï¼Œåˆ™å®ƒå¼•ç”¨æ•è·çš„å˜é‡è‡ªç„¶å·²ç»ä¸å­˜åœ¨äº†ï¼Œè¡Œä¸º *æœªå®šä¹‰*
                    - å¦‚æœå¯èƒ½ï¼Œå°½é‡**é¿å…**æ•è·æŒ‡é’ˆæˆ–å¼•ç”¨ 
            ```
            size_t v1 = 42;
            printf("v1 = %zu @ %p\n", v1, &v1);                                       // v1 = 42 @ 0x7ffcc11095e0

            auto f1 = [v1]  { printf("f1 v1 = %zu @ %p\n", v1, &v1); return v1;   };  
            auto f2 = [&v1] { printf("f2 v1 = %zu @ %p\n", v1, &v1); return ++v1; };  

            v1 = 0;
            size_t j1 = f1();                                                         // f1 v1 = 42 @ 0x7ffcc11095e8
            printf("after f1: v1 = %zu, j1 = %zu\n", v1, j1);                         // after f1: v1 = 0, j1 = 42

            v1 = 0;
            size_t j2 = f2();                                                         // f2 v1 = 0 @ 0x7ffcc11095e0
            printf("after f2: v1 = %zu, j2 = %zu\n", v1, j2);                         // after f2: v1 = 1, j2 = 1
            ```
        - æ•è·çš„å£°æ˜
            - `[]`ï¼šç©ºæ•è·åˆ—è¡¨ã€‚`lambda`ä¸èƒ½ä½¿ç”¨æ‰€åœ¨å‡½æ•°ä¸­çš„å˜é‡
            - `[identifier_list]`ï¼š`identifier_list`æ˜¯ä¸€ä¸ªé€—å·åˆ†éš”çš„åå­—åˆ—è¡¨ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæ•è·åˆ—è¡¨ä¸­çš„å˜é‡éƒ½é‡‡ç”¨å€¼æ•è·ï¼Œå³è¢«æ‹·è´ã€‚åå­—å‰å¦‚ä½¿ç”¨`&`ï¼Œåˆ™æ˜¾ç¤ºæŒ‡æ˜è¯¥å˜é‡é‡‡ç”¨å¼•ç”¨æ•è·
            - `[&]`ï¼š éšå¼å¼•ç”¨æ•è·åˆ—è¡¨ã€‚ç¼–è¯‘å™¨è‡ªåŠ¨å¼•ç”¨æ•è·`lambda`å‡½æ•°ä½“ä¸­ä½¿ç”¨çš„å±€éƒ¨å˜é‡
            - `[=]`ï¼š éšå¼å€¼æ•è·åˆ—è¡¨ã€‚ç¼–è¯‘å™¨è‡ªåŠ¨å€¼æ•è·`lambda`å‡½æ•°ä½“ä¸­ä½¿ç”¨çš„å±€éƒ¨å˜é‡
            - `[&, identifier_list]`ï¼šæ··åˆå¼å¼•ç”¨æ•è·åˆ—è¡¨ã€‚`identifier_list`æ˜¯ä¸€ä¸ªé€—å·åˆ†éš”çš„åå­—åˆ—è¡¨ï¼ŒåŒ…å«0è‡³å¤šä¸ªå˜é‡ï¼Œå˜é‡åå‰**ä¸èƒ½**æœ‰`&`ã€‚è¿™äº›å˜é‡é‡‡ç”¨å€¼æ•è·æ–¹å¼ï¼Œè€Œå…¶ä»–è¢«éšå¼æ•è·çš„å˜é‡åˆ™ä¸€å¾‹é‡‡ç”¨å¼•ç”¨æ•è·
            - `[=, identifier_list]`ï¼šæ··åˆå¼å€¼æ•è·åˆ—è¡¨ã€‚`identifier_list`æ˜¯ä¸€ä¸ªé€—å·åˆ†éš”çš„åå­—åˆ—è¡¨ï¼ŒåŒ…å«0è‡³å¤šä¸ªå˜é‡ï¼Œ**ä¸èƒ½**åŒ…å«`this`ï¼Œå˜é‡åå‰ *å¿…é¡»* æœ‰`&`ã€‚è¿™äº›å˜é‡é‡‡ç”¨å¼•ç”¨æ•è·æ–¹å¼ï¼Œè€Œå…¶ä»–è¢«éšå¼æ•è·çš„å˜é‡åˆ™ä¸€å¾‹é‡‡ç”¨å€¼æ•è·
    - å‚æ•°åˆ—è¡¨
        - å¯¹äºéå¯å˜`lambda`ï¼Œå¯ä»¥è¿åŒæ‹¬å·ä¸€èµ·å¿½ç•¥ã€‚å¦‚å¿½ç•¥ï¼Œåˆ™ç­‰ä»·äºæŒ‡å®š *ç©ºçš„* å‚æ•°åˆ—è¡¨
        - **ä¸èƒ½**æœ‰ *é»˜è®¤å‚æ•°*
    - è¿”å›å€¼ç±»å‹
        - å¯ä»¥å¿½ç•¥ï¼Œæ­¤æ—¶è¿”å›å€¼ç±»å‹ç”±è¿”å›çš„è¡¨è¾¾å¼çš„ç±»å‹æ¨æ–­è€Œæ¥
            - å¦‚æœ`lambda`çš„å‡½æ•°ä½“åŒ…å«ä»»ä½•å•ä¸€`return`è¯­å¥ä¹‹å¤–çš„å†…å®¹ï¼Œä¸”æœªæŒ‡å®šè¿”å›å€¼ç±»å‹ï¼Œåˆ™è¿”å›`void`
        - å¦‚ä¸å¿½ç•¥ï¼Œåˆ™å¿…é¡»ä½¿ç”¨ *å°¾ç½®è¿”å›* 
        ```
        // ok. refers returning int
        std::transform(vec.begin(), vec.end(), vec.begin(), [] (int i)  
        {
            return i < 0 ? -i : i;  
        });
        
        // error. refers returning void but returns int -- from C++ Primer 5th Edition
        // note: at least on g++ (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0 this one runs correctly with -std=c++11
        std::transform(vec.begin(), vec.end(), vec.begin(), [] (int i)  
        {
            if (i < 0) return -i; else return i;
        });
        
        // ok. returns int
        std::transform(vec.begin(), vec.end(), vec.begin(), [] (int i)  -> int
        {
            if (i < 0) return -i; else return i;
        });
            ```
    - å‡½æ•°ä½“ï¼šå¿…è¦ç»„æˆéƒ¨åˆ†
    ```
    auto f = [] { return 42; };
    std::cout << f() << std::endl;  // 42

    std::stable_sort(vec.begin(), vec.end(), [] (const string & a, const string & b) 
    { 
        return a.size() < b.size(); 
    });
    ```
- å‚æ•°ç»‘å®š
    - ç”¨å‡½æ•°ä»£æ›¿`lambda`
        - å¯¹äºè¦å¤šæ¬¡ä½¿ç”¨çš„æ“ä½œï¼Œåº”å½“ç¼–å†™å‡½æ•°å¹¶å¤ç”¨ï¼Œè€Œä¸æ˜¯ç¼–å†™ä¸€å †é‡å¤çš„`lambda`
        - æ•è·åˆ—è¡¨ä¸ºç©ºçš„`lambda`ä¹Ÿå¯ä»¥ç”¨å‡½æ•°æ¥ä»£æ›¿
    - å¦‚æœè¦ç”¨å‡½æ•°ä»£æ›¿æ•è·äº†å±€éƒ¨å˜é‡çš„`lambda`ï¼Œå¯ä»¥ä½¿ç”¨`std::bind()`å¯¹å‡½æ•°è¿›è¡Œ *å‚æ•°ç»‘å®š* 
        - å¤´æ–‡ä»¶`<functional>`ã€‚ä½¿ç”¨æ–¹æ³•
        ```
        auto newCallable = std::bind(callable, arg_list);
        ```
        - å¯ä»¥çœ‹åšé€šç”¨çš„å‡½æ•°é€‚é…å™¨ã€‚è°ƒç”¨`newCallable`æ—¶ï¼Œ`newCallable`ä¼šè°ƒç”¨`callable`ï¼Œå¹¶å‘å…¶ä¼ é€’`arg_list`ä¸­çš„å‚æ•°
        - `arg_list`ï¼š
            - é€—å·åˆ†éš”çš„å‚æ•°åˆ—è¡¨
            - å¯ä»¥åŒ…å«å½¢å¦‚`_n`çš„ *å ä½ç¬¦* ï¼ˆ`n`ä¸ºæ•´æ•°ï¼‰ï¼Œè¡¨ç¤ºå°†è¦ä¼ é€’ç»™`callable`çš„å‚æ•°
                - `_1`è¡¨ç¤º`newCallable`çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œ`_2`ä¸ºç¬¬äºŒä¸ªï¼Œä»¥æ­¤ç±»æ¨
        ```
        bool checkSize(const std::string & s, const std::string::size_type &sz)
        {
            return s.size() >= sz;
        }
        
        auto check6 = std::bind(checkSize, _1, 6);
        ```

#### å†æ¢è¿­ä»£å™¨

- æ’å…¥è¿­ä»£å™¨
- `iostream`è¿­ä»£å™¨
- åå‘è¿­ä»£å™¨
    - [`std::back_inserter()`](https://en.cppreference.com/w/cpp/iterator/back_inserter)
        - æ¥å—ä¸€ä¸ªæŒ‡å‘å®¹å™¨çš„ *å¼•ç”¨* ï¼Œ è¿”å›ä¸è¯¥å®¹å™¨ç»‘å®šçš„è¿­ä»£å™¨
        - é€šè¿‡æ­¤è¿­ä»£å™¨èµ‹å€¼æ—¶ï¼Œèµ‹å€¼è¿ç®—ç¬¦è°ƒç”¨`push_back()`è®²ä¸€ä¸ªå…·æœ‰ç»™å®šå€¼çš„å…ƒç´ æ·»åŠ åˆ°å®¹å™¨ä¸­
        ```
        std::vector<int> vec;                                     // empty vector
        std::vector<int>::iterator it = std::back_inserter(vec);
        *it = 42;                                                 // equal to: vec.push_back(42);
        ```
        - å¸¸å¸¸ä½¿ç”¨`std::back_inserter()`åˆ›å»ºè¿­ä»£å™¨ï¼Œä½œä¸ºç®—æ³•çš„ *ç›®çš„ä½ç½®* ä½¿ç”¨
        ```
        std::vector<int> vec;                                     // empty vector
        std::fill_n(std::back_inserter(vec), 10, 0);              // insert 10 elements to vec
        ```

#### æ³›å‹ç®—æ³•ç»“æ„

- ç±»è¿­ä»£å™¨
- ç®—æ³•å½¢å‚æ¨¡å¼
- ç®—æ³•å‘½åè§„èŒƒ

#### ç‰¹å®šå®¹å™¨ç®—æ³•

#### æ ‡å‡†åº“ç®—æ³•æ¦‚è§ˆ

- é¡ºåºæŸ¥æ‰¾
- å…¶ä»–åªè¯»ç®—æ³•
- äºŒåˆ†æŸ¥æ‰¾
- å†™å®¹å™¨å…ƒç´ 
- åˆ’åˆ†ä¸æ’åº
- é€šç”¨é‡æ’æ“ä½œ
- æ’åˆ—ç®—æ³•
- æœ‰åºåºåˆ—çš„é›†åˆç®—æ³•
- æ•°å€¼ç®—æ³•

#### éšæœºæ•°

- éšæœºæ•°åˆ†å¸ƒ
- éšæœºæ•°å¼•æ“

### ğŸŒ± [Chap 12] åŠ¨æ€å†…å­˜

- 

### ğŸŒ± [Chap 17] æ ‡å‡†åº“ç‰¹æ®Šè®¾æ–½

- 

### ğŸŒ± [Chap 18] ç”¨äºå¤§å‹å·¥ç¨‹çš„å·¥å…·

#### å¼‚å¸¸å¤„ç†

- `C++`æ ‡å‡†å¼‚å¸¸
    - `exception`ï¼šæœ€é€šç”¨çš„å¼‚å¸¸ç±»`exception`ï¼ŒåªæŠ¥å‘Šå¼‚å¸¸çš„å‘ç”Ÿï¼Œä¸æä¾›ä»»ä½•é¢å¤–ä¿¡æ¯
    - `stdexcept`ï¼šå‡ ç§å¸¸ç”¨çš„å¼‚å¸¸ç±»
        - `excpetion`ï¼šæœ€å¸¸è§çš„é—®é¢˜
        - `runtime_error`ï¼šæ‰€æœ‰RE
            - `range_error`ï¼šREï¼Œç”Ÿæˆçš„ç»“æœè¶…å‡ºäº†æœ‰æ„ä¹‰çš„å€¼åŸŸèŒƒå›´
            - `overflow_error`ï¼šREï¼Œè®¡ç®—æº¢å‡º
            - `underflow_error`ï¼šREï¼Œè®¡ç®—æº¢å‡º
        - `logic_error`ï¼šæ‰€æœ‰é€»è¾‘é”™è¯¯
            - `domain_error`ï¼šé€»è¾‘é”™è¯¯ï¼Œå‚æ•°å¯¹åº”çš„ç»“æœå€¼ä¸å­˜åœ¨
            - `invalid_argument`ï¼šé€»è¾‘é”™è¯¯ï¼Œæ— æ•ˆå‚æ•°
            - `length_error`ï¼šé€»è¾‘é”™è¯¯ï¼Œè¯•å›¾åˆ›å»ºä¸€ä¸ªè¶…å‡ºè¯¥ç±»å‹æœ€å¤§é•¿åº¦çš„å¯¹è±¡
            - `out_of_range`ï¼šé€»è¾‘é”™è¯¯ï¼Œä½¿ç”¨äº†ä¸€ä¸ªè¶…å‡ºæœ‰æ•ˆèŒƒå›´çš„å€¼
    - `new`ï¼š`bad_alloc`å¼‚å¸¸ç±» => 12.1.2
    - `type_info`ï¼š`bad_cast`å¼‚å¸¸ç±» => 19.2
- `excpetion`ï¼Œ`bad_alloc`å’Œ`bad_cast`åªèƒ½é»˜è®¤åˆå§‹åŒ–ï¼Œä¸èƒ½ä¼ å‚ï¼›å…¶ä½™å¼‚å¸¸å¿…é¡»ä¼ å‚ï¼ˆ`C`é£æ ¼å­—ç¬¦ä¸²ï¼‰
- å¼‚å¸¸ç±»å‹ä¹‹å®šä¹‰äº†ä¸€ä¸ªåä¸º`what`çš„æˆå‘˜å‡½æ•°ï¼Œè¿”å›`C`é£æ ¼å­—ç¬¦ä¸²`const char *`ï¼Œæä¾›å¼‚å¸¸çš„æ–‡æœ¬ä¿¡æ¯ã€‚
  å¦‚æœæ­¤å¼‚å¸¸ä¼ å…¥äº†åˆå§‹å‚æ•°ï¼Œåˆ™è¿”å›ä¹‹ï¼›å¦åˆ™è¿”å›å€¼ç”±ç¼–è¯‘å™¨å†³å®šã€‚

### ğŸŒ± [Chap 19] ç‰¹æ®Šå·¥å…·ä¸æŠ€æœ¯

- 


















